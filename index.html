<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Todo App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/cdn.min.js"></script>


    <style>
        /* Basic Styling & Theme Variables */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Light Theme (Default) */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f3f4f6; /* gray-100 */
            --bg-tertiary: #e5e7eb; /* gray-200 */
            --text-primary: #111827; /* gray-900 */
            --text-secondary: #6b7280; /* gray-500 */
            --text-tertiary: #4b5563; /* gray-600 */
            --border-color: #e5e7eb; /* gray-200 */
            --accent-color: #3b82f6; /* blue-500 */
            --accent-hover: #2563eb; /* blue-600 */
            --danger-color: #ef4444; /* red-500 */
            --danger-hover: #dc2626; /* red-600 */
            --warning-color: #f59e0b; /* amber-500 */
            --success-color: #22c55e; /* green-500 */
            --info-color: #60a5fa; /* blue-400 */
        }

        /* Dark Theme */
        html.dark {
            --bg-primary: #1f2937; /* gray-800 */
            --bg-secondary: #374151; /* gray-700 */
            --bg-tertiary: #4b5563; /* gray-600 */
            --text-primary: #f9fafb; /* gray-50 */
            --text-secondary: #9ca3af; /* gray-400 */
            --text-tertiary: #d1d5db; /* gray-300 */
            --border-color: #4b5563; /* gray-600 */
            /* Keep accent/status colors or adjust if needed */
        }

        /* Apply Theme Variables */
        .bg-primary { background-color: var(--bg-primary); }
        .bg-secondary { background-color: var(--bg-secondary); }
        .bg-tertiary { background-color: var(--bg-tertiary); }
        .text-primary { color: var(--text-primary); }
        .text-secondary { color: var(--text-secondary); }
        .text-tertiary { color: var(--text-tertiary); }
        .border-themed { border-color: var(--border-color); }
        .accent-button { background-color: var(--accent-color); color: white; }
        .accent-button:hover { background-color: var(--accent-hover); }
        .danger-button { background-color: var(--danger-color); color: white; }
        .danger-button:hover { background-color: var(--danger-hover); }
        .info-button { background-color: var(--info-color); color: white; }
        .info-button:hover { background-color: #3b82f6; } /* blue-500 */
        .secondary-button { background-color: var(--bg-tertiary); color: var(--text-tertiary); }
        .secondary-button:hover { background-color: var(--border-color); }


        /* Custom Styles */
        .task-item {
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
            cursor: grab;
        }
        .task-item:active {
            cursor: grabbing;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transform: scale(1.02);
            background-color: var(--bg-tertiary); /* Slightly change bg on grab */
        }
        .task-item.dragging {
            opacity: 0.5;
            border: 2px dashed var(--accent-color);
        }
        .task-item.completed .task-title {
            text-decoration: line-through;
            color: var(--text-secondary);
        }
        .priority-high { border-left: 4px solid var(--danger-color); }
        .priority-medium { border-left: 4px solid var(--warning-color); }
        .priority-low { border-left: 4px solid var(--success-color); }

        /* Custom Checkbox */
        .custom-checkbox {
            appearance: none; -webkit-appearance: none;
            height: 1.25rem; width: 1.25rem;
            border: 2px solid var(--border-color); border-radius: 0.25rem;
            display: inline-block; position: relative; cursor: pointer;
            margin-right: 0.5rem; vertical-align: middle; flex-shrink: 0;
        }
        .custom-checkbox:checked { background-color: var(--accent-color); border-color: var(--accent-color); }
        .custom-checkbox:checked::after {
            content: ''; position: absolute; left: 5px; top: 1px;
            width: 5px; height: 10px; border: solid white;
            border-width: 0 2px 2px 0; transform: rotate(45deg);
        }

        /* Modal Styling */
        .modal { display: none; position: fixed; z-index: 50; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { max-width: 500px; width: 90%; animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        /* Notification Styling */
        #notification-area { position: fixed; bottom: 1rem; right: 1rem; z-index: 100; display: flex; flex-direction: column; gap: 0.5rem; }
        .notification { padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); opacity: 0; transform: translateX(100%); transition: opacity 0.3s ease, transform 0.3s ease; }
        .notification.show { opacity: 1; transform: translateX(0); }
        .notification-success { background-color: var(--success-color); color: white; }
        .notification-error { background-color: var(--danger-color); color: white; }
        .notification-info { background-color: var(--info-color); color: white; }
        .notification-warning { background-color: var(--warning-color); color: #1f2937; } /* Dark text on yellow */

        /* Loading Spinner */
        .loader { border: 4px solid var(--bg-secondary); border-top: 4px solid var(--accent-color); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 2rem auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Drag placeholder */
        .drag-over { border-top: 2px dashed var(--accent-color); background-color: rgba(59, 130, 246, 0.1); }

        /* View Switcher & Graph Container */
        .view-container { display: block; } /* Default view */
        .view-container.hidden { display: none; }
        #graph-view { min-height: 400px; /* Ensure canvas has height */ }

        /* Batch Action Bar */
        #batch-action-bar {
            position: fixed;
            bottom: -100px; /* Start hidden below screen */
            left: 50%;
            transform: translateX(-50%);
            z-index: 60;
            transition: bottom 0.3s ease-in-out;
            width: calc(100% - 2rem); /* Responsive width */
            max-width: 600px;
        }
        #batch-action-bar.active {
            bottom: 1rem; /* Slide in */
        }

        /* Date Filter Buttons */
        .date-filter-btn {
             transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
             border: 1px solid transparent;
        }
        .date-filter-btn.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-hover);
        }
        .date-filter-btn:not(.active) {
             background-color: var(--bg-tertiary);
             color: var(--text-tertiary);
             border-color: var(--border-color);
        }
         .date-filter-btn:not(.active):hover {
             background-color: var(--border-color);
         }

        /* Inline Due Date Alert */
        .due-date-alert {
            display: inline-block;
            width: 0.6rem;
            height: 0.6rem;
            border-radius: 50%;
            margin-left: 0.3rem;
            vertical-align: middle;
        }
        .due-date-alert.expired { background-color: var(--danger-color); }
        .due-date-alert.soon { background-color: var(--warning-color); }
        .due-date-alert.ontime { background-color: var(--success-color); }

        /* Time Tracker */
        .time-tracker-btn {
            background: none; border: none; padding: 0; cursor: pointer;
            color: var(--text-secondary);
            transition: color 0.2s ease;
            width: 1.5rem; /* Fixed width */
            height: 1.5rem; /* Fixed height */
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
         .time-tracker-btn:hover { color: var(--accent-color); }
         .time-tracker-btn.tracking { color: var(--danger-color); } /* Red when tracking */
         .time-tracker-btn.tracking:hover { color: var(--danger-hover); }

         #global-timer-display {
             min-width: 80px; /* Ensure space for time */
             text-align: right;
         }

    </style>
</head>
<body class="bg-primary text-primary">

    <div id="login-screen" class="fixed inset-0 bg-primary z-50 flex items-center justify-center p-4">
        <div class="w-full max-w-md p-8 bg-secondary rounded-lg shadow-lg border border-themed">
            <h2 class="text-2xl font-bold text-center text-primary mb-6">Login to Todo App</h2>
            <form id="login-form">
                <div class="mb-4">
                    <label for="username" class="block text-sm font-medium text-secondary mb-1">Username</label>
                    <input type="text" id="username" name="username" required class="w-full px-3 py-2 bg-primary border border-themed rounded-md focus:outline-none focus:ring-2 focus:ring-accent-color text-primary" placeholder="e.g., demo_user">
                </div>
                <div class="mb-6">
                    <label for="password" class="block text-sm font-medium text-secondary mb-1">Password</label>
                    <input type="password" id="password" name="password" required class="w-full px-3 py-2 bg-primary border border-themed rounded-md focus:outline-none focus:ring-2 focus:ring-accent-color text-primary" placeholder="e.g., password">
                </div>
                <button type="submit" class="w-full accent-button font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">Login</button>
                <p class="text-xs text-secondary text-center mt-4">Use any username/password (e.g., demo/demo) - data is stored locally per username.</p>
            </form>
        </div>
    </div>

    <div id="app-container" class="hidden min-h-screen flex flex-col">

        <header class="bg-secondary border-b border-themed shadow-sm p-4 sticky top-0 z-40">
            <div class="container mx-auto flex justify-between items-center">
                <h1 class="text-xl md:text-2xl font-bold text-primary">My Todo App</h1>
                <div class="flex items-center space-x-2 md:space-x-4">
                    <span id="welcome-message" class="text-sm text-secondary hidden lg:block"></span>
                    <div id="global-timer-display" class="text-sm text-secondary font-mono bg-primary px-2 py-1 rounded border border-themed">
                        --:--:--
                    </div>
                    <button id="theme-toggle-btn" class="p-2 rounded-md hover:bg-primary border border-transparent hover:border-themed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-accent-color" aria-label="Toggle theme">
                        <i class="fas fa-sun text-yellow-500"></i> <i class="fas fa-moon text-indigo-400 hidden"></i> </button>
                     <button id="logout-btn" class="text-sm danger-button font-medium py-1 px-3 rounded-md transition duration-150 ease-in-out">Logout</button>
                </div>
            </div>
        </header>

        <main class="container mx-auto p-4 flex-grow flex flex-col md:flex-row gap-6">

            <aside class="w-full md:w-1/4 lg:w-1/5 bg-secondary p-4 rounded-lg border border-themed shadow-sm h-fit md:sticky md:top-20"> {/* Sticky sidebar */}
                <h2 class="text-lg font-semibold mb-4 text-primary">Filters & Sort</h2>

                <div class="mb-4">
                    <label for="search-input" class="block text-sm font-medium text-secondary mb-1">Search Tasks</label>
                    <input type="search" id="search-input" placeholder="Search title/desc..." class="w-full px-3 py-2 bg-primary border border-themed rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-accent-color text-primary">
                </div>

                <div class="mb-4">
                    <label for="filter-status" class="block text-sm font-medium text-secondary mb-1">Status</label>
                    <select id="filter-status" class="w-full px-3 py-2 bg-primary border border-themed rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-accent-color text-primary">
                        <option value="all">All</option>
                        <option value="active">Active</option>
                        <option value="completed">Completed</option>
                    </select>
                </div>

                <div class="mb-4">
                    <label for="filter-priority" class="block text-sm font-medium text-secondary mb-1">Priority</label>
                    <select id="filter-priority" class="w-full px-3 py-2 bg-primary border border-themed rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-accent-color text-primary">
                        <option value="all">All Priorities</option>
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>

                 <div class="mb-4">
                    <label for="filter-category" class="block text-sm font-medium text-secondary mb-1">Category</label>
                    <select id="filter-category" class="w-full px-3 py-2 bg-primary border border-themed rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-accent-color text-primary">
                        <option value="all">All Categories</option>
                        </select>
                </div>

                <div class="mb-4">
                    <label for="sort-tasks" class="block text-sm font-medium text-secondary mb-1">Sort by</label>
                    <select id="sort-tasks" class="w-full px-3 py-2 bg-primary border border-themed rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-accent-color text-primary">
                        <option value="default">Order Added / Manual</option>
                        <option value="dueDateAsc">Due Date (Asc)</option>
                        <option value="dueDateDesc">Due Date (Desc)</option>
                        <option value="priority">Priority (High-Low)</option>
                        <option value="titleAsc">Title (A-Z)</option>
                        <option value="timeTrackedDesc">Time Tracked (Desc)</option> {/* New Sort Option */}
                    </select>
                </div>

                 <div class="mt-6 border-t border-themed pt-4">
                     <h3 class="text-md font-semibold mb-2 text-primary">View</h3>
                     <div class="flex gap-2">
                         <button id="list-view-btn" class="flex-1 secondary-button text-sm font-medium py-1.5 px-3 rounded-md transition duration-150 ease-in-out active"><i class="fas fa-list mr-1"></i> List</button>
                         <button id="graph-view-btn" class="flex-1 secondary-button text-sm font-medium py-1.5 px-3 rounded-md transition duration-150 ease-in-out"><i class="fas fa-chart-pie mr-1"></i> Graph</button>
                     </div>
                 </div>

            </aside>

            <section class="w-full md:w-3/4 lg:w-4/5">

                <div class="mb-4 flex flex-wrap gap-2 justify-between items-center">
                     <div class="flex flex-wrap gap-2">
                        <button id="add-task-btn" class="accent-button font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out text-sm"><i class="fas fa-plus mr-1"></i>Add Task</button>
                        <button id="export-json-btn" class="secondary-button text-sm font-medium py-2 px-3 rounded-md transition duration-150 ease-in-out"><i class="fas fa-file-export mr-1"></i>Export</button>
                        <label for="import-json-input" class="secondary-button text-sm font-medium py-2 px-3 rounded-md cursor-pointer transition duration-150 ease-in-out">
                            <i class="fas fa-file-import mr-1"></i>Import
                        </label>
                        <input type="file" id="import-json-input" accept=".json" class="hidden">
                     </div>
                     <div class="text-sm text-secondary">
                        <span id="task-count" class="mr-2"></span>
                        <button id="undo-btn" class="text-accent-color hover:underline disabled:opacity-50 disabled:cursor-not-allowed" disabled>Undo</button>
                     </div>
                </div>

                <div class="mb-4 flex flex-wrap gap-2">
                    <button data-filter="overall" class="date-filter-btn text-xs font-medium py-1 px-3 rounded-md active">Overall</button>
                    <button data-filter="today" class="date-filter-btn text-xs font-medium py-1 px-3 rounded-md">Today</button>
                    <button data-filter="week" class="date-filter-btn text-xs font-medium py-1 px-3 rounded-md">This Week</button>
                    <button data-filter="month" class="date-filter-btn text-xs font-medium py-1 px-3 rounded-md">This Month</button>
                </div>


                <div id="list-view" class="view-container">
                    <div id="loading-indicator" class="hidden">
                        <div class="loader"></div>
                    </div>
                    <ul id="task-list" class="space-y-3">
                        <p id="no-tasks-message" class="text-center text-secondary py-6">No tasks found. Add one to get started!</p>
                    </ul>
                </div>

                <div id="graph-view" class="view-container hidden bg-secondary p-4 rounded-lg border border-themed shadow-sm">
                    <h2 class="text-xl font-semibold text-primary mb-4 text-center">Task Overview</h2>
                     <div class="max-w-sm mx-auto"> {/* Limit chart size */}
                        <canvas id="task-chart"></canvas>
                    </div>
                    <p id="graph-message" class="text-center text-secondary mt-4 text-sm"></p>
                </div>

            </section>

        </main>

        <footer class="bg-secondary border-t border-themed mt-8 py-4">
            <div class="container mx-auto text-center text-xs text-secondary">
                Todo App &copy; 2025 | Data stored locally. Time tracker resets daily (00:00 UTC).
            </div>
        </footer>

    </div> <div id="task-modal" class="modal">
        <div class="modal-content bg-primary p-6 rounded-lg shadow-xl border border-themed">
            <form id="task-form">
                <input type="hidden" id="task-id">
                <h3 id="modal-title" class="text-xl font-semibold mb-4 text-primary">Add New Task</h3>

                <div class="mb-4">
                    <label for="task-title" class="block text-sm font-medium text-secondary mb-1">Title <span class="text-red-500">*</span></label>
                    <input type="text" id="task-title" required class="w-full px-3 py-2 bg-primary border border-themed rounded-md focus:outline-none focus:ring-2 focus:ring-accent-color text-primary" placeholder="e.g., Buy groceries">
                </div>

                <div class="mb-4">
                    <label for="task-description" class="block text-sm font-medium text-secondary mb-1">Description / Notes</label>
                    <textarea id="task-description" rows="3" class="w-full px-3 py-2 bg-primary border border-themed rounded-md focus:outline-none focus:ring-2 focus:ring-accent-color text-primary" placeholder="Add details or notes here..."></textarea>
                </div>

                <div class="mb-4">
                    <label for="task-due-date" class="block text-sm font-medium text-secondary mb-1">Due Date</label>
                    <input type="date" id="task-due-date" class="w-full px-3 py-2 bg-primary border border-themed rounded-md focus:outline-none focus:ring-2 focus:ring-accent-color text-primary">
                </div>

                <div class="mb-4">
                    <label for="task-priority" class="block text-sm font-medium text-secondary mb-1">Priority</label>
                    <select id="task-priority" class="w-full px-3 py-2 bg-primary border border-themed rounded-md focus:outline-none focus:ring-2 focus:ring-accent-color text-primary">
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                        <option value="low">Low</option>
                    </select>
                </div>

                <div class="mb-4">
                    <label for="task-category" class="block text-sm font-medium text-secondary mb-1">Category</label>
                    <div class="flex gap-2">
                         <input type="text" id="task-category" list="category-datalist" class="flex-grow px-3 py-2 bg-primary border border-themed rounded-md focus:outline-none focus:ring-2 focus:ring-accent-color text-primary" placeholder="e.g., Work, Personal">
                         <datalist id="category-datalist"></datalist>
                         <button type="button" id="add-category-btn" class="accent-button text-sm px-3 rounded-md" title="Add as new category if not exists">+</button>
                    </div>
                </div>

                <div class="flex justify-end gap-3 mt-6">
                    <button type="button" id="cancel-task-btn" class="secondary-button font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">Cancel</button>
                    <button type="submit" id="save-task-btn" class="accent-button font-semibold py-2 px-4 rounded-md transition duration-150 ease-in-out">Save Task</button>
                </div>
            </form>
        </div>
    </div>

    <div id="batch-action-bar" class="bg-secondary dark:bg-gray-800 p-3 rounded-lg shadow-lg border border-themed flex items-center justify-between gap-4">
        <span id="batch-count" class="text-sm font-medium text-primary">X items selected</span>
        <div class="flex gap-2">
            <button id="batch-complete-btn" class="info-button text-xs font-medium py-1 px-3 rounded-md transition duration-150 ease-in-out"><i class="fas fa-check-double mr-1"></i>Complete</button>
            <button id="batch-delete-btn" class="danger-button text-xs font-medium py-1 px-3 rounded-md transition duration-150 ease-in-out"><i class="fas fa-trash-alt mr-1"></i>Delete</button>
        </div>
    </div>


    <div id="notification-area"></div>

    <script>
        // Make date-fns available globally for easier use
        const { format, differenceInDays, startOfDay, endOfDay, startOfWeek, endOfWeek, startOfMonth, endOfMonth, parseISO, isBefore, isEqual, isAfter, getUnixTime, fromUnixTime, formatDistanceToNow, getUTCDay, getUTCDate, getUTCMonth, getUTCFullYear, startOfToday } = dateFns;

        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const loginScreen = document.getElementById('login-screen');
            const loginForm = document.getElementById('login-form');
            const appContainer = document.getElementById('app-container');
            const welcomeMessage = document.getElementById('welcome-message');
            const logoutBtn = document.getElementById('logout-btn');
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const addTaskBtn = document.getElementById('add-task-btn');
            const taskListUl = document.getElementById('task-list');
            const taskModal = document.getElementById('task-modal');
            const taskForm = document.getElementById('task-form');
            const modalTitle = document.getElementById('modal-title');
            const cancelTaskBtn = document.getElementById('cancel-task-btn');
            const saveTaskBtn = document.getElementById('save-task-btn');
            const taskIdInput = document.getElementById('task-id');
            const taskTitleInput = document.getElementById('task-title');
            const taskDescriptionInput = document.getElementById('task-description');
            const taskDueDateInput = document.getElementById('task-due-date');
            const taskPriorityInput = document.getElementById('task-priority');
            const taskCategoryInput = document.getElementById('task-category');
            const categoryDatalist = document.getElementById('category-datalist');
            const addCategoryBtn = document.getElementById('add-category-btn');
            const searchInput = document.getElementById('search-input');
            const filterStatusSelect = document.getElementById('filter-status');
            const filterPrioritySelect = document.getElementById('filter-priority');
            const filterCategorySelect = document.getElementById('filter-category');
            const sortTasksSelect = document.getElementById('sort-tasks');
            const taskCountSpan = document.getElementById('task-count');
            const noTasksMessage = document.getElementById('no-tasks-message');
            const loadingIndicator = document.getElementById('loading-indicator');
            const undoBtn = document.getElementById('undo-btn');
            const exportJsonBtn = document.getElementById('export-json-btn');
            const importJsonInput = document.getElementById('import-json-input');
            const notificationArea = document.getElementById('notification-area');
            const listViewContainer = document.getElementById('list-view');
            const graphViewContainer = document.getElementById('graph-view');
            const listViewBtn = document.getElementById('list-view-btn');
            const graphViewBtn = document.getElementById('graph-view-btn');
            const taskChartCanvas = document.getElementById('task-chart');
            const graphMessage = document.getElementById('graph-message');
            const batchActionBar = document.getElementById('batch-action-bar');
            const batchCountSpan = document.getElementById('batch-count');
            const batchDeleteBtn = document.getElementById('batch-delete-btn');
            const batchCompleteBtn = document.getElementById('batch-complete-btn');
            const dateFilterButtons = document.querySelectorAll('.date-filter-btn');
            const globalTimerDisplay = document.getElementById('global-timer-display');


            // --- State ---
            let tasks = [];
            let categories = new Set();
            let currentUser = null;
            let lastState = null;
            let currentFilters = {
                status: 'all',
                priority: 'all',
                category: 'all',
                searchTerm: '',
                dateRange: 'overall' // 'today', 'week', 'month', 'overall'
            };
            let currentSort = 'default';
            let currentView = 'list'; // 'list' or 'graph'
            let taskChart = null; // Chart.js instance
            let draggedItem = null;
            let globalTimerInterval = null; // Interval ID for the header timer
            let currentlyTrackingTaskId = null; // ID of the task being tracked
            let trackingStartTime = null; // Timestamp (ms) when tracking started

            // --- Constants ---
            const LOCAL_STORAGE_PREFIX = 'todoApp_v2_'; // Updated prefix for potentially breaking changes
            const DUE_SOON_DAYS = 2; // How many days before due date counts as "soon"

            // --- Utility Functions ---
            const generateId = () => `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
            const getLocalStorageKey = (key) => `${LOCAL_STORAGE_PREFIX}${currentUser}_${key}`;

            const showNotification = (message, type = 'info', duration = 3000) => {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type} text-sm`; // Added text-sm
                notification.textContent = message;
                notificationArea.appendChild(notification);
                notification.offsetHeight; // Trigger reflow
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => notification.remove(), 300);
                }, duration);
            };

            // Format seconds into HH:MM:SS
            const formatTime = (totalSeconds) => {
                if (isNaN(totalSeconds) || totalSeconds < 0) return '00:00:00';
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = Math.floor(totalSeconds % 60);
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            };

            // Get current date in YYYY-MM-DD format (UTC)
            const getTodayUTCString = () => {
                const now = new Date();
                return `${now.getUTCFullYear()}-${String(now.getUTCMonth() + 1).padStart(2, '0')}-${String(now.getUTCDate()).padStart(2, '0')}`;
            };


            // --- Local Storage & State Management ---
            const saveState = () => {
                if (!currentUser) return;
                try {
                    localStorage.setItem(getLocalStorageKey('tasks'), JSON.stringify(tasks));
                    localStorage.setItem(getLocalStorageKey('categories'), JSON.stringify(Array.from(categories)));
                    localStorage.setItem('todoApp_theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
                    // Save time tracking state
                    localStorage.setItem(getLocalStorageKey('currentlyTrackingTaskId'), currentlyTrackingTaskId || '');
                    localStorage.setItem(getLocalStorageKey('trackingStartTime'), trackingStartTime ? trackingStartTime.toString() : '');
                    localStorage.setItem(getLocalStorageKey('lastResetDateUTC'), getTodayUTCString()); // Store last reset date

                } catch (e) {
                    console.error("Error saving state:", e);
                    showNotification("Error saving data.", "error");
                }
            };

            const loadState = () => {
                if (!currentUser) return;
                setLoading(true);
                try {
                    // Load theme first
                    loadTheme();

                    // Check for daily reset
                    resetDailyTrackedTimeIfNeeded();

                    // Load Tasks and Categories
                    const storedTasks = localStorage.getItem(getLocalStorageKey('tasks'));
                    const storedCategories = localStorage.getItem(getLocalStorageKey('categories'));
                    tasks = storedTasks ? JSON.parse(storedTasks) : [];
                    const loadedCats = storedCategories ? JSON.parse(storedCategories) : ['Work', 'Personal', 'Shopping'];
                    categories = new Set(loadedCats);

                    // Add default tasks if none exist for the user
                    if (tasks.length === 0) {
                        addSampleTasks();
                    }

                    // Data Migration/Defaults (ensure all tasks have needed properties)
                    tasks.forEach(task => {
                        if (!task.id) task.id = generateId();
                        if (task.completed === undefined) task.completed = false;
                        if (!task.priority) task.priority = 'medium';
                        if (!task.category) task.category = 'Uncategorized';
                        if (task.trackedTime === undefined) task.trackedTime = 0; // Initialize tracked time
                        if (task.isTracking !== undefined) delete task.isTracking; // Remove obsolete property if present
                    });

                    // Load time tracking state
                    currentlyTrackingTaskId = localStorage.getItem(getLocalStorageKey('currentlyTrackingTaskId')) || null;
                    const storedStartTime = localStorage.getItem(getLocalStorageKey('trackingStartTime'));
                    trackingStartTime = storedStartTime ? parseInt(storedStartTime, 10) : null;

                    // Resume timer if a task was being tracked
                    if (currentlyTrackingTaskId && trackingStartTime) {
                        startGlobalTimer(currentlyTrackingTaskId, trackingStartTime);
                    } else {
                        currentlyTrackingTaskId = null;
                        trackingStartTime = null;
                         updateGlobalTimerDisplay(0); // Display 0 if nothing is tracked
                    }


                    updateCategoryFilters();
                    renderTasks(); // Initial render
                    switchView(currentView); // Apply current view (usually list)

                } catch (e) {
                    console.error("Error loading state:", e);
                    tasks = []; categories = new Set(['Work', 'Personal', 'Shopping']);
                    showNotification("Error loading data. Resetting tasks.", "error");
                    renderTasks();
                } finally {
                    setLoading(false);
                }
            };

             // --- Sample Data ---
            const addSampleTasks = () => {
                const today = new Date();
                const sampleTasks = [
                    { title: "Final Project Report", description: "Complete Section 3 and 4", dueDate: format(dateFns.addDays(today, 5), 'yyyy-MM-dd'), priority: "high", category: "Work", completed: false },
                    { title: "Grocery Shopping", description: "Milk, Eggs, Bread, Coffee", dueDate: format(dateFns.addDays(today, 1), 'yyyy-MM-dd'), priority: "medium", category: "Personal", completed: false },
                    { title: "Schedule Dentist Appointment", description: "", dueDate: null, priority: "low", category: "Personal", completed: false },
                    { title: "Read Chapter 5 of JS Book", description: "Focus on async/await", dueDate: format(dateFns.addDays(today, 3), 'yyyy-MM-dd'), priority: "medium", category: "Learning", completed: true },
                    { title: "Pay Electricity Bill", description: "Due next week", dueDate: format(dateFns.addDays(today, 7), 'yyyy-MM-dd'), priority: "high", category: "Bills", completed: false },
                    { title: "Plan Weekend Trip", description: "Look up destinations and hotels", dueDate: format(dateFns.addDays(today, 10), 'yyyy-MM-dd'), priority: "medium", category: "Personal", completed: false },
                    { title: "Fix Bug #123", description: "Issue reported by QA team", dueDate: format(dateFns.subDays(today, 1), 'yyyy-MM-dd'), priority: "high", category: "Work", completed: false }, // Overdue
                    { title: "Call Mom", description: "", dueDate: format(today, 'yyyy-MM-dd'), priority: "medium", category: "Personal", completed: false }, // Due today
                    { title: "Prepare Presentation Slides", description: "For Monday meeting", dueDate: format(dateFns.addDays(today, 4), 'yyyy-MM-dd'), priority: "high", category: "Work", completed: false },
                    { title: "Water the Plants", description: "", dueDate: null, priority: "low", category: "Home", completed: true },
                ];

                sampleTasks.forEach(taskData => {
                    const newTask = {
                        id: generateId(),
                        ...taskData,
                        createdAt: new Date().toISOString(),
                        trackedTime: Math.floor(Math.random() * 3600) // Add some random tracked time (0 to 1 hr)
                    };
                    tasks.push(newTask); // Add to end for initial load
                    addCategory(taskData.category);
                });
                saveState(); // Save the sample tasks
                showNotification("Added sample tasks to get you started!", "info");
            };


            const saveLastState = () => {
                lastState = JSON.stringify({ tasks, categories: Array.from(categories) });
                undoBtn.disabled = false;
            };

            const restoreLastState = () => {
                if (!lastState) return;
                // Stop any active timer before restoring state
                if (currentlyTrackingTaskId) {
                    pauseTimeTracker(currentlyTrackingTaskId, false); // Pause without saving last state again
                }
                const previousState = JSON.parse(lastState);
                tasks = previousState.tasks;
                categories = new Set(previousState.categories);
                lastState = null;
                undoBtn.disabled = true;
                saveState();
                updateCategoryFilters();
                renderTasks(); // Render the restored state
                showNotification("Last action undone.", "info");
                // Re-evaluate batch action bar state
                updateBatchActionBar();
                 // Re-evaluate time tracking state (though it should be stopped)
                if (currentlyTrackingTaskId) {
                     startGlobalTimer(currentlyTrackingTaskId, trackingStartTime);
                } else {
                     stopGlobalTimer();
                     updateGlobalTimerDisplay(0);
                }
            };

            // --- Theme Management ---
            const applyTheme = (theme) => {
                const isDark = theme === 'dark';
                document.documentElement.classList.toggle('dark', isDark);
                themeToggleBtn.querySelector('.fa-sun').classList.toggle('hidden', isDark);
                themeToggleBtn.querySelector('.fa-moon').classList.toggle('hidden', !isDark);
                // Update chart theme if chart exists
                if (taskChart) {
                    taskChart.options.color = isDark ? 'rgba(249, 250, 251, 0.8)' : 'rgba(55, 65, 81, 0.8)'; // text-gray-50 / text-gray-700 with opacity
                    taskChart.options.scales.x.grid.color = isDark ? 'rgba(75, 85, 99, 0.3)' : 'rgba(229, 231, 235, 0.5)'; // gray-600 / gray-200
                    taskChart.options.scales.y.grid.color = isDark ? 'rgba(75, 85, 99, 0.3)' : 'rgba(229, 231, 235, 0.5)';
                    taskChart.options.scales.x.ticks.color = isDark ? 'rgba(209, 213, 219, 0.8)' : 'rgba(107, 114, 128, 0.8)'; // gray-300 / gray-500
                    taskChart.options.scales.y.ticks.color = isDark ? 'rgba(209, 213, 219, 0.8)' : 'rgba(107, 114, 128, 0.8)';
                    taskChart.update();
                }
            };
            const toggleTheme = () => {
                const newTheme = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
                applyTheme(newTheme);
                saveState();
            };
            const loadTheme = () => applyTheme(localStorage.getItem('todoApp_theme') || 'light');


            // --- UI Rendering ---
            const setLoading = (isLoading) => {
                loadingIndicator.classList.toggle('hidden', !isLoading);
                if (currentView === 'list') {
                    taskListUl.classList.toggle('hidden', isLoading);
                    noTasksMessage.classList.toggle('hidden', isLoading);
                } else {
                    graphViewContainer.classList.toggle('opacity-50', isLoading); // Dim graph view
                }
            };

            // --- Task Element Creation ---
            const createTaskElement = (task) => {
                const li = document.createElement('li');
                li.className = `task-item bg-secondary p-4 rounded-lg border border-themed shadow-sm flex items-start gap-3 priority-${task.priority} ${task.completed ? 'completed opacity-60' : ''}`;
                li.dataset.id = task.id;
                li.draggable = true;

                // Left side (Checkbox + Content)
                const leftDiv = document.createElement('div');
                leftDiv.className = 'flex-grow flex items-start gap-3';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = task.completed;
                checkbox.className = 'custom-checkbox mt-1 batch-select';
                checkbox.addEventListener('change', () => {
                    toggleTaskComplete(task.id);
                    updateBatchActionBar(); // Update bar on check/uncheck
                });

                const contentDiv = document.createElement('div');
                contentDiv.className = 'flex-grow';

                const titleSpan = document.createElement('span');
                titleSpan.textContent = task.title;
                titleSpan.className = 'task-title font-medium text-primary block';

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'text-sm text-secondary mt-1 space-y-1';

                if (task.description) {
                    const descP = document.createElement('p');
                    descP.textContent = task.description.length > 100 ? task.description.substring(0, 97) + '...' : task.description; // Truncate long descriptions slightly
                    descP.title = task.description; // Show full on hover
                    detailsDiv.appendChild(descP);
                }

                const metaDiv = document.createElement('div');
                metaDiv.className = 'flex flex-wrap gap-x-3 gap-y-1 items-center text-xs'; // Smaller meta text

                // Category
                if (task.category && task.category !== 'Uncategorized') {
                    const categorySpan = document.createElement('span');
                    categorySpan.innerHTML = `<i class="fas fa-tag mr-1 opacity-75"></i>${task.category}`;
                    categorySpan.className = 'bg-tertiary dark:bg-gray-600 px-1.5 py-0.5 rounded';
                    metaDiv.appendChild(categorySpan);
                }

                 // Due Date & Alert
                if (task.dueDate) {
                    const dateSpan = document.createElement('span');
                    try {
                         // Use UTC midnight for comparisons to avoid timezone issues with just dates
                        const dueDate = parseISO(task.dueDate + 'T00:00:00Z'); // Treat as UTC
                        const today = startOfToday(); // Local start of today
                        const diff = differenceInDays(dueDate, today); // Days remaining

                        const formattedDate = format(dueDate, 'MMM d, yyyy');
                        let alertClass = '';
                        let alertTitle = '';

                        if (!task.completed) {
                            if (isBefore(dueDate, today)) {
                                alertClass = 'expired'; // Red
                                alertTitle = 'Overdue';
                            } else if (diff >= 0 && diff <= DUE_SOON_DAYS) {
                                alertClass = 'soon'; // Yellow
                                alertTitle = `Due in ${formatDistanceToNow(dueDate, { addSuffix: true })}`;
                            } else {
                                alertClass = 'ontime'; // Green
                                alertTitle = `Due ${formatDistanceToNow(dueDate, { addSuffix: true })}`;
                            }
                        }

                        dateSpan.innerHTML = `<i class="fas fa-calendar-alt mr-1 opacity-75"></i>${formattedDate}`;
                        if (alertClass) {
                            dateSpan.innerHTML += `<span class="due-date-alert ${alertClass}" title="${alertTitle}"></span>`;
                        }
                        if (alertClass === 'expired') {
                            dateSpan.classList.add('text-red-500', 'font-medium');
                        } else if (alertClass === 'soon') {
                             dateSpan.classList.add('text-amber-600', 'dark:text-amber-400');
                        }

                    } catch (e) {
                        console.error("Error parsing date:", task.dueDate, e);
                        dateSpan.innerHTML = `<i class="fas fa-calendar-alt mr-1 opacity-75"></i>Invalid Date`;
                    }
                    metaDiv.appendChild(dateSpan);
                }

                // Tracked Time
                const timeSpan = document.createElement('span');
                timeSpan.innerHTML = `<i class="fas fa-stopwatch mr-1 opacity-75"></i>${formatTime(task.trackedTime || 0)}`;
                timeSpan.className = 'text-xs';
                timeSpan.id = `time-${task.id}`; // ID for updating time display
                metaDiv.appendChild(timeSpan);


                detailsDiv.appendChild(metaDiv);
                contentDiv.appendChild(titleSpan);
                contentDiv.appendChild(detailsDiv);

                leftDiv.appendChild(checkbox);
                leftDiv.appendChild(contentDiv);

                // Right side (Actions + Timer)
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex flex-col items-end gap-1 md:gap-2 ml-auto pl-2 flex-shrink-0';

                // Time Tracker Button
                const timerBtn = document.createElement('button');
                const isCurrentlyTrackingThis = currentlyTrackingTaskId === task.id;
                timerBtn.innerHTML = `<i class="fas ${isCurrentlyTrackingThis ? 'fa-pause' : 'fa-play'}"></i>`;
                timerBtn.className = `time-tracker-btn ${isCurrentlyTrackingThis ? 'tracking' : ''}`;
                timerBtn.title = isCurrentlyTrackingThis ? "Pause Timer" : "Start Timer";
                timerBtn.dataset.taskId = task.id;
                timerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleTimeTrackerToggle(task.id);
                });

                // Action Buttons (Edit, Delete)
                const actionBtnsDiv = document.createElement('div');
                actionBtnsDiv.className = 'flex items-center gap-1 md:gap-2 mt-1';

                const editBtn = document.createElement('button');
                editBtn.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                editBtn.className = 'text-blue-500 hover:text-blue-700 p-1 text-sm';
                editBtn.title = "Edit Task";
                editBtn.addEventListener('click', (e) => { e.stopPropagation(); openEditModal(task.id); });

                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                deleteBtn.className = 'text-red-500 hover:text-red-700 p-1 text-sm';
                deleteBtn.title = "Delete Task";
                deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); if (confirm(`Delete task: "${task.title}"?`)) deleteTask(task.id); });

                actionBtnsDiv.appendChild(editBtn);
                actionBtnsDiv.appendChild(deleteBtn);

                actionsDiv.appendChild(timerBtn);
                actionsDiv.appendChild(actionBtnsDiv);


                li.appendChild(leftDiv);
                li.appendChild(actionsDiv);

                // Drag and Drop Listeners
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragover', handleDragOver);
                li.addEventListener('dragleave', handleDragLeave);
                li.addEventListener('drop', handleDrop);
                li.addEventListener('dragend', handleDragEnd);

                return li;
            };


            // --- Main Render Function ---
            const renderTasks = () => {
                if (currentView === 'list') {
                    renderListView();
                } else if (currentView === 'graph') {
                    renderGraphView();
                }
                updateBatchActionBar(); // Update bar visibility after render
            };


            // --- List View Rendering ---
            const renderListView = () => {
                taskListUl.innerHTML = '';
                setLoading(true);

                const filteredTasks = getFilteredAndSortedTasks();

                if (filteredTasks.length === 0) {
                    noTasksMessage.classList.remove('hidden');
                    noTasksMessage.textContent = (currentFilters.searchTerm || currentFilters.status !== 'all' || currentFilters.priority !== 'all' || currentFilters.category !== 'all' || currentFilters.dateRange !== 'overall')
                        ? 'No tasks match your current filters.'
                        : 'No tasks yet. Add one to get started!';
                } else {
                    noTasksMessage.classList.add('hidden');
                    filteredTasks.forEach(task => {
                        const taskElement = createTaskElement(task);
                        taskListUl.appendChild(taskElement);
                    });
                }

                taskCountSpan.textContent = `${filteredTasks.length} task(s)`;
                setLoading(false);
            };

             // --- Filtering and Sorting Logic ---
            const getFilteredAndSortedTasks = () => {
                 // Apply basic filters first
                let filtered = tasks.filter(task => {
                    const statusMatch = currentFilters.status === 'all' ||
                                        (currentFilters.status === 'completed' && task.completed) ||
                                        (currentFilters.status === 'active' && !task.completed);
                    const priorityMatch = currentFilters.priority === 'all' || task.priority === currentFilters.priority;
                    const categoryMatch = currentFilters.category === 'all' || task.category === currentFilters.category;
                    const searchMatch = !currentFilters.searchTerm ||
                                        task.title.toLowerCase().includes(currentFilters.searchTerm) ||
                                        (task.description && task.description.toLowerCase().includes(currentFilters.searchTerm));
                    return statusMatch && priorityMatch && categoryMatch && searchMatch;
                });

                // Apply date range filter
                if (currentFilters.dateRange !== 'overall') {
                    let startDate, endDate;
                    const today = startOfToday(); // Local time start of day

                    switch (currentFilters.dateRange) {
                        case 'today':
                            startDate = today;
                            endDate = endOfDay(today);
                            break;
                        case 'week':
                            startDate = startOfWeek(today, { weekStartsOn: 1 }); // Assuming week starts Monday
                            endDate = endOfWeek(today, { weekStartsOn: 1 });
                            break;
                        case 'month':
                            startDate = startOfMonth(today);
                            endDate = endOfMonth(today);
                            break;
                    }

                    if (startDate && endDate) {
                        filtered = filtered.filter(task => {
                            if (!task.dueDate) return false; // Exclude tasks without due dates
                            try {
                                // Parse task due date as local time for comparison with local ranges
                                const dueDate = parseISO(task.dueDate);
                                return !isBefore(dueDate, startDate) && !isAfter(dueDate, endDate);
                            } catch {
                                return false; // Invalid date format
                            }
                        });
                    }
                }


                // Apply sorting
                filtered.sort((a, b) => {
                    switch (currentSort) {
                        case 'dueDateAsc':
                            if (!a.dueDate) return 1; if (!b.dueDate) return -1;
                            return differenceInDays(parseISO(a.dueDate), parseISO(b.dueDate));
                        case 'dueDateDesc':
                             if (!a.dueDate) return 1; if (!b.dueDate) return -1;
                            return differenceInDays(parseISO(b.dueDate), parseISO(a.dueDate));
                        case 'priority':
                            const priorityOrder = { high: 1, medium: 2, low: 3 };
                            return (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
                        case 'titleAsc':
                            return a.title.localeCompare(b.title);
                        case 'timeTrackedDesc':
                             return (b.trackedTime || 0) - (a.trackedTime || 0);
                        case 'default':
                        default:
                            // Use original tasks array index for default/manual order
                            return tasks.findIndex(t => t.id === a.id) - tasks.findIndex(t => t.id === b.id);
                    }
                });

                return filtered;
            };


            // --- Graph View Rendering ---
            const renderGraphView = () => {
                setLoading(true);
                const filteredTasks = getFilteredAndSortedTasks(); // Get tasks based on current filters

                const statusCounts = { active: 0, completed: 0 };
                const priorityCounts = { high: 0, medium: 0, low: 0 };
                const categoryCounts = {};

                filteredTasks.forEach(task => {
                    // Status
                    if (task.completed) statusCounts.completed++; else statusCounts.active++;
                    // Priority
                    priorityCounts[task.priority] = (priorityCounts[task.priority] || 0) + 1;
                    // Category
                    const cat = task.category || 'Uncategorized';
                    categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
                });

                 // Determine if dark mode is active for chart colors
                const isDarkMode = document.documentElement.classList.contains('dark');
                const textColor = isDarkMode ? 'rgba(249, 250, 251, 0.8)' : 'rgba(55, 65, 81, 0.8)';
                const gridColor = isDarkMode ? 'rgba(75, 85, 99, 0.3)' : 'rgba(229, 231, 235, 0.5)';
                const tickColor = isDarkMode ? 'rgba(209, 213, 219, 0.8)' : 'rgba(107, 114, 128, 0.8)';

                // Chart Configuration (Example: Pie chart for status)
                const chartData = {
                    labels: ['Active', 'Completed'],
                    datasets: [{
                        label: 'Task Status',
                        data: [statusCounts.active, statusCounts.completed],
                        backgroundColor: [
                            'rgba(245, 158, 11, 0.7)',  // amber-500 with opacity
                            'rgba(34, 197, 94, 0.7)'   // green-500 with opacity
                        ],
                        borderColor: [
                             isDarkMode ? 'rgba(55, 65, 81, 1)' : 'rgba(255, 255, 255, 1)', // gray-700 / white
                             isDarkMode ? 'rgba(55, 65, 81, 1)' : 'rgba(255, 255, 255, 1)'
                        ],
                        borderWidth: 1
                    }]
                };

                const chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { color: textColor }
                        },
                        title: {
                            display: true,
                            text: `Status Overview (${filteredTasks.length} tasks)`,
                            color: textColor,
                            font: { size: 16 }
                        }
                    },
                     // Scales are not typically used for pie charts, but keep for consistency if changing chart type
                    scales: {
                        x: { display: false, grid: { color: gridColor }, ticks: { color: tickColor } },
                        y: { display: false, grid: { color: gridColor }, ticks: { color: tickColor } }
                    },
                    color: textColor // Default text color for chart elements
                };

                // Destroy previous chart instance if it exists
                if (taskChart) {
                    taskChart.destroy();
                }

                // Create new chart
                 if (taskChartCanvas) {
                    const ctx = taskChartCanvas.getContext('2d');
                    taskChart = new Chart(ctx, {
                        type: 'pie', // Or 'bar', 'doughnut' etc.
                        data: chartData,
                        options: chartOptions
                    });
                 } else {
                    console.error("Chart canvas element not found");
                 }


                graphMessage.textContent = filteredTasks.length > 0
                    ? `Showing overview for ${filteredTasks.length} tasks matching current filters.`
                    : 'No tasks match current filters to display in the graph.';

                setLoading(false);
            };

            // --- View Switching ---
            const switchView = (view) => {
                currentView = view;
                const isList = view === 'list';

                // Toggle button active states
                listViewBtn.classList.toggle('active', isList);
                listViewBtn.classList.toggle('secondary-button', !isList); // Use secondary style when inactive
                listViewBtn.classList.toggle('accent-button', isList); // Use accent style when active

                graphViewBtn.classList.toggle('active', !isList);
                graphViewBtn.classList.toggle('secondary-button', isList);
                graphViewBtn.classList.toggle('accent-button', !isList);


                // Show/hide containers with transition (optional simple fade)
                listViewContainer.style.transition = 'opacity 0.3s ease';
                graphViewContainer.style.transition = 'opacity 0.3s ease';

                if (isList) {
                    listViewContainer.classList.remove('hidden');
                    graphViewContainer.classList.add('hidden');
                    renderListView(); // Re-render list view
                } else {
                    listViewContainer.classList.add('hidden');
                    graphViewContainer.classList.remove('hidden');
                    renderGraphView(); // Render graph view
                }
            };


            // --- Task Operations ---
            const addTask = (taskData) => {
                saveLastState();
                const newTask = {
                    id: generateId(),
                    ...taskData,
                    completed: false,
                    createdAt: new Date().toISOString(),
                    trackedTime: 0 // Initialize tracked time
                };
                tasks.unshift(newTask);
                addCategory(taskData.category);
                saveState();
                renderTasks();
                showNotification(`Task "${newTask.title}" added.`, "success");
            };

            const editTask = (id, updatedData) => {
                saveLastState();
                const taskIndex = tasks.findIndex(task => task.id === id);
                if (taskIndex > -1) {
                    // Preserve existing trackedTime and createdAt
                    const originalTask = tasks[taskIndex];
                    tasks[taskIndex] = {
                        ...originalTask, // Keep original properties like id, createdAt, trackedTime
                        ...updatedData   // Apply updates
                    };
                    addCategory(updatedData.category);
                    saveState();
                    renderTasks();
                    showNotification(`Task "${updatedData.title}" updated.`, "success");
                }
            };

            const deleteTask = (id) => {
                 // If the task being deleted is currently tracked, stop the timer first
                if (currentlyTrackingTaskId === id) {
                    pauseTimeTracker(id, false); // Pause without saving state again
                }
                saveLastState();
                const taskToDelete = tasks.find(task => task.id === id);
                tasks = tasks.filter(task => task.id !== id);
                saveState();
                renderTasks();
                if (taskToDelete) {
                    showNotification(`Task "${taskToDelete.title}" deleted.`, "info");
                }
            };

            const toggleTaskComplete = (id) => {
                saveLastState();
                const taskIndex = tasks.findIndex(task => task.id === id);
                if (taskIndex > -1) {
                    tasks[taskIndex].completed = !tasks[taskIndex].completed;
                     // If completing a task that is being tracked, stop the timer
                    if (tasks[taskIndex].completed && currentlyTrackingTaskId === id) {
                        pauseTimeTracker(id, false); // Pause without saving state again
                    }
                    saveState();
                    renderTasks();
                    const status = tasks[taskIndex].completed ? 'completed' : 'marked active';
                    showNotification(`Task "${tasks[taskIndex].title}" ${status}.`, "info");
                }
            };

            // --- Category Management ---
            const addCategory = (categoryName) => {
                const trimmedName = categoryName?.trim(); // Handle potential null/undefined
                if (trimmedName && !categories.has(trimmedName)) {
                    categories.add(trimmedName);
                    updateCategoryFilters();
                    updateCategoryDatalist();
                    saveState();
                }
            };
            const updateCategoryFilters = () => {
                const currentFilterValue = filterCategorySelect.value;
                filterCategorySelect.innerHTML = '<option value="all">All Categories</option>';
                const sortedCategories = Array.from(categories).sort((a, b) => a.localeCompare(b));
                sortedCategories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat; option.textContent = cat;
                    filterCategorySelect.appendChild(option);
                });
                if (categories.has(currentFilterValue)) filterCategorySelect.value = currentFilterValue;
                 else { filterCategorySelect.value = 'all'; currentFilters.category = 'all'; }
            };
            const updateCategoryDatalist = () => {
                categoryDatalist.innerHTML = '';
                const sortedCategories = Array.from(categories).sort((a, b) => a.localeCompare(b));
                sortedCategories.forEach(cat => {
                    const option = document.createElement('option'); option.value = cat;
                    categoryDatalist.appendChild(option);
                });
            };


            // --- Modal Handling ---
            const openTaskModal = (mode = 'add', taskId = null) => {
                taskForm.reset(); taskIdInput.value = ''; taskCategoryInput.value = '';
                if (mode === 'edit' && taskId) {
                    const task = tasks.find(t => t.id === taskId);
                    if (task) {
                        modalTitle.textContent = 'Edit Task'; saveTaskBtn.textContent = 'Update Task';
                        taskIdInput.value = task.id; taskTitleInput.value = task.title;
                        taskDescriptionInput.value = task.description || '';
                        taskDueDateInput.value = task.dueDate || '';
                        taskPriorityInput.value = task.priority || 'medium';
                        taskCategoryInput.value = task.category || '';
                    } else { console.error("Task not found:", taskId); showNotification("Task not found.", "error"); return; }
                } else {
                    modalTitle.textContent = 'Add New Task'; saveTaskBtn.textContent = 'Save Task';
                    taskPriorityInput.value = 'medium';
                }
                updateCategoryDatalist();
                taskModal.classList.add('active');
                taskTitleInput.focus();
            };
            const openEditModal = (taskId) => openTaskModal('edit', taskId); // Alias for clarity
            const closeTaskModal = () => taskModal.classList.remove('active');

            // --- Event Handlers ---
            const handleLoginFormSubmit = (e) => {
                e.preventDefault();
                const username = loginForm.username.value.trim();
                if (username) {
                    currentUser = username;
                    loginScreen.style.display = 'none';
                    appContainer.classList.remove('hidden');
                    welcomeMessage.textContent = `Welcome, ${currentUser}!`;
                    loadState(); // Load theme, check reset, load data, resume timer
                } else { showNotification("Please enter a username.", "error"); }
            };
            const handleLogout = () => {
                if (confirm("Logout? Active timer will stop. Data is saved locally.")) {
                     if (currentlyTrackingTaskId) pauseTimeTracker(currentlyTrackingTaskId, false); // Stop timer before logout
                    currentUser = null; tasks = []; categories = new Set(); lastState = null;
                    appContainer.classList.add('hidden'); loginScreen.style.display = 'flex';
                    welcomeMessage.textContent = '';
                    stopGlobalTimer(); // Clear header timer display
                    updateGlobalTimerDisplay(0);
                }
            };
            const handleTaskFormSubmit = (e) => {
                e.preventDefault();
                const id = taskIdInput.value;
                const taskData = {
                    title: taskTitleInput.value.trim(),
                    description: taskDescriptionInput.value.trim(),
                    dueDate: taskDueDateInput.value || null,
                    priority: taskPriorityInput.value,
                    category: taskCategoryInput.value.trim() || 'Uncategorized'
                };
                if (!taskData.title) { showNotification("Task title is required.", "error"); taskTitleInput.focus(); return; }
                if (id) editTask(id, taskData); else addTask(taskData);
                closeTaskModal();
            };
            const handleFilterChange = () => {
                currentFilters.status = filterStatusSelect.value;
                currentFilters.priority = filterPrioritySelect.value;
                currentFilters.category = filterCategorySelect.value;
                currentFilters.searchTerm = searchInput.value.trim().toLowerCase();
                renderTasks(); // Re-render based on filters
            };
             const handleDateFilterChange = (event) => {
                const button = event.target.closest('.date-filter-btn');
                if (!button) return;

                // Update active state
                dateFilterButtons.forEach(btn => btn.classList.remove('active', 'accent-button'));
                button.classList.add('active', 'accent-button');

                currentFilters.dateRange = button.dataset.filter;
                renderTasks();
            };

            const handleSortChange = () => { currentSort = sortTasksSelect.value; renderTasks(); };
            const handleAddCategory = () => {
                const categoryName = taskCategoryInput.value.trim();
                if (categoryName) { addCategory(categoryName); showNotification(`Category "${categoryName}" added/selected.`, "info"); }
                 else { showNotification("Please enter a category name.", "error"); }
            };

            // --- Batch Actions ---
            const getSelectedTaskIds = () => Array.from(taskListUl.querySelectorAll('.batch-select:checked')).map(cb => cb.closest('.task-item').dataset.id);

            const updateBatchActionBar = () => {
                const selectedIds = getSelectedTaskIds();
                const count = selectedIds.length;
                if (count > 0) {
                    batchCountSpan.textContent = `${count} item${count > 1 ? 's' : ''} selected`;
                    batchActionBar.classList.add('active');
                } else {
                    batchActionBar.classList.remove('active');
                }
            };

            const handleDeleteSelected = () => {
                const selectedIds = getSelectedTaskIds();
                if (selectedIds.length === 0) return;
                if (confirm(`Delete ${selectedIds.length} selected task(s)?`)) {
                     // Stop timers for any selected tasks being deleted
                    selectedIds.forEach(id => {
                        if (currentlyTrackingTaskId === id) {
                            pauseTimeTracker(id, false);
                        }
                    });
                    saveLastState();
                    tasks = tasks.filter(task => !selectedIds.includes(task.id));
                    saveState();
                    renderTasks(); // Re-render list
                    showNotification(`${selectedIds.length} task(s) deleted.`, "info");
                }
            };

            const handleCompleteSelected = () => {
                const selectedIds = getSelectedTaskIds();
                if (selectedIds.length === 0) return;
                saveLastState();
                let completedCount = 0;
                tasks = tasks.map(task => {
                    if (selectedIds.includes(task.id) && !task.completed) {
                        task.completed = true;
                         // Stop timer if completing a tracked task
                        if (currentlyTrackingTaskId === task.id) {
                            pauseTimeTracker(task.id, false);
                        }
                        completedCount++;
                    }
                    return task;
                });
                saveState();
                renderTasks();
                if (completedCount > 0) showNotification(`${completedCount} task(s) marked complete.`, "info");
                 else showNotification("Selected tasks already complete.", "info");
            };


            // --- Import/Export ---
            const handleExportTasks = () => { /* ... (keep existing implementation) ... */
                if (tasks.length === 0) { showNotification("No tasks to export.", "info"); return; }
                try {
                    const dataToExport = { exportDate: new Date().toISOString(), user: currentUser, tasks: tasks, categories: Array.from(categories) };
                    const jsonString = JSON.stringify(dataToExport, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = `todo_app_export_${currentUser}_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showNotification("Tasks exported successfully.", "success");
                } catch (e) { console.error("Error exporting:", e); showNotification("Failed to export tasks.", "error"); }
            };
            const handleImportTasks = (event) => { /* ... (keep existing implementation, ensure trackedTime is handled) ... */
                 const file = event.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (!importedData || !Array.isArray(importedData.tasks)) throw new Error("Invalid JSON. Expected 'tasks' array.");
                        if (confirm(`Import ${importedData.tasks.length} tasks? This REPLACES current tasks for user "${currentUser}".`)) {
                            if (currentlyTrackingTaskId) pauseTimeTracker(currentlyTrackingTaskId, false); // Stop timer before import
                            saveLastState();
                            tasks = importedData.tasks.map(task => ({
                                id: task.id || generateId(), title: task.title || 'Untitled', description: task.description || '',
                                dueDate: task.dueDate || null, priority: task.priority || 'medium', category: task.category || 'Uncategorized',
                                completed: task.completed || false, createdAt: task.createdAt || new Date().toISOString(),
                                trackedTime: task.trackedTime || 0 // Import tracked time
                            }));
                            categories = new Set(); // Reset categories before adding imported/extracted ones
                            if (Array.isArray(importedData.categories)) importedData.categories.forEach(cat => categories.add(cat));
                             else tasks.forEach(task => addCategory(task.category)); // Extract from tasks if not present
                            saveState();
                            updateCategoryFilters(); renderTasks();
                            showNotification(`Imported ${importedData.tasks.length} tasks.`, "success");
                        }
                    } catch (error) { console.error("Import error:", error); showNotification(`Import failed: ${error.message}`, "error"); }
                     finally { importJsonInput.value = null; }
                };
                reader.onerror = () => { showNotification("Failed to read import file.", "error"); importJsonInput.value = null; };
                reader.readAsText(file);
            };


            // --- Drag and Drop Handlers ---
            function handleDragStart(e) { /* ... (keep existing implementation) ... */
                 draggedItem = this; e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', this.dataset.id);
                 setTimeout(() => this.classList.add('dragging'), 0);
            }
            function handleDragOver(e) { /* ... (keep existing implementation) ... */
                 e.preventDefault(); e.dataTransfer.dropEffect = 'move';
                 const targetItem = e.target.closest('.task-item');
                 if (targetItem && targetItem !== draggedItem) {
                     document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                     targetItem.classList.add('drag-over');
                 }
            }
            function handleDragLeave(e) { /* ... (keep existing implementation) ... */
                 const targetItem = e.target.closest('.task-item'); if (targetItem) targetItem.classList.remove('drag-over');
            }
            function handleDrop(e) { /* ... (keep existing implementation) ... */
                 e.preventDefault(); e.stopPropagation();
                 const targetItem = e.target.closest('.task-item');
                 document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                 if (targetItem && draggedItem && targetItem !== draggedItem) {
                     const draggedId = draggedItem.dataset.id; const targetId = targetItem.dataset.id;
                     const draggedIndex = tasks.findIndex(t => t.id === draggedId); const targetIndex = tasks.findIndex(t => t.id === targetId);
                     if (draggedIndex !== -1 && targetIndex !== -1) {
                         saveLastState();
                         const [movedTask] = tasks.splice(draggedIndex, 1);
                         const newTargetIndex = tasks.findIndex(t => t.id === targetId); // Recalculate index after splice
                         tasks.splice(newTargetIndex, 0, movedTask);
                         saveState();
                         // Force sort to default to reflect manual order
                         sortTasksSelect.value = 'default'; currentSort = 'default';
                         renderTasks();
                         showNotification("Task order updated.", "info");
                     }
                 }
                 if (draggedItem) draggedItem.classList.remove('dragging');
                 draggedItem = null;
            }
            function handleDragEnd(e) { /* ... (keep existing implementation) ... */
                 this.classList.remove('dragging'); document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over')); draggedItem = null;
            }


            // --- Keyboard Shortcuts ---
            const handleKeyPress = (e) => { /* ... (keep existing implementation) ... */
                if (e.ctrlKey && e.altKey && (e.key === 'n' || e.key === 'N')) { e.preventDefault(); if (!taskModal.classList.contains('active')) openTaskModal('add'); }
                if (e.key === 'Escape' && taskModal.classList.contains('active')) closeTaskModal();
                if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) { e.preventDefault(); if (!undoBtn.disabled) restoreLastState(); }
            };


            // --- Time Tracking ---

            // Reset tracked time for all tasks if it's a new day (UTC)
            const resetDailyTrackedTimeIfNeeded = () => {
                 const lastResetDateStr = localStorage.getItem(getLocalStorageKey('lastResetDateUTC'));
                 const todayUTCStr = getTodayUTCString();

                 if (lastResetDateStr !== todayUTCStr) {
                     console.log(`New day detected (UTC: ${todayUTCStr}). Resetting tracked time.`);
                     let resetCount = 0;
                     tasks = tasks.map(task => {
                         if (task.trackedTime && task.trackedTime > 0) {
                             task.trackedTime = 0;
                             resetCount++;
                         }
                         return task;
                     });

                     // Also clear any running timer state from previous day
                      currentlyTrackingTaskId = null;
                      trackingStartTime = null;
                      localStorage.removeItem(getLocalStorageKey('currentlyTrackingTaskId'));
                      localStorage.removeItem(getLocalStorageKey('trackingStartTime'));
                      stopGlobalTimer(); // Ensure header timer is stopped
                      updateGlobalTimerDisplay(0);


                     if (resetCount > 0) {
                         // Save the modified tasks and the new reset date immediately
                         saveState();
                         showNotification(`Daily tracked time reset for ${resetCount} task(s).`, "info");
                     } else {
                         // Still save the new reset date even if no tasks had time
                         localStorage.setItem(getLocalStorageKey('lastResetDateUTC'), todayUTCStr);
                     }
                 }
            };

            const updateGlobalTimerDisplay = (totalSeconds) => {
                globalTimerDisplay.textContent = formatTime(totalSeconds);
            };

            const startGlobalTimer = (taskId, startTime) => {
                stopGlobalTimer(); // Clear any existing interval

                const task = tasks.find(t => t.id === taskId);
                if (!task) return;

                const initialTrackedTime = task.trackedTime || 0;

                globalTimerInterval = setInterval(() => {
                    const now = Date.now();
                    const elapsed = Math.floor((now - startTime) / 1000);
                    const currentTotalSeconds = initialTrackedTime + elapsed;
                    updateGlobalTimerDisplay(currentTotalSeconds);

                    // Also update the specific task's time display in the list if visible
                    const taskTimeSpan = document.getElementById(`time-${taskId}`);
                    if (taskTimeSpan) {
                        taskTimeSpan.textContent = formatTime(currentTotalSeconds);
                    }

                }, 1000);

                 // Update button state
                 updateTimerButton(taskId, true);
            };

            const stopGlobalTimer = () => {
                if (globalTimerInterval) {
                    clearInterval(globalTimerInterval);
                    globalTimerInterval = null;
                }
                 // Update button state (find the previously tracked task)
                if (currentlyTrackingTaskId) {
                    updateTimerButton(currentlyTrackingTaskId, false);
                }
                 // Don't reset display here, pauseTimeTracker handles final update
            };

             const updateTimerButton = (taskId, isTracking) => {
                const timerBtn = taskListUl.querySelector(`.time-tracker-btn[data-task-id="${taskId}"]`);
                 if (timerBtn) {
                    timerBtn.innerHTML = `<i class="fas ${isTracking ? 'fa-pause' : 'fa-play'}"></i>`;
                    timerBtn.classList.toggle('tracking', isTracking);
                    timerBtn.title = isTracking ? "Pause Timer" : "Start Timer";
                }
            };


            const startTimeTracker = (taskId) => {
                // Pause any currently running timer first
                if (currentlyTrackingTaskId && currentlyTrackingTaskId !== taskId) {
                    pauseTimeTracker(currentlyTrackingTaskId);
                }

                const task = tasks.find(t => t.id === taskId);
                if (!task || task.completed) {
                    showNotification("Cannot track time for completed tasks.", "warning");
                    return;
                }

                currentlyTrackingTaskId = taskId;
                trackingStartTime = Date.now(); // Record start time in ms

                startGlobalTimer(taskId, trackingStartTime);
                saveState(); // Save the new tracking state
                showNotification(`Timer started for "${task.title}".`, "info");
            };

            const pauseTimeTracker = (taskId, shouldSaveState = true) => {
                if (currentlyTrackingTaskId !== taskId || !trackingStartTime) return; // Not tracking this task

                const taskIndex = tasks.findIndex(t => t.id === taskId);
                if (taskIndex > -1) {
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - trackingStartTime) / 1000);
                    tasks[taskIndex].trackedTime = (tasks[taskIndex].trackedTime || 0) + elapsedSeconds;

                    // Update UI immediately before stopping timer
                    updateGlobalTimerDisplay(tasks[taskIndex].trackedTime);
                     const taskTimeSpan = document.getElementById(`time-${taskId}`);
                    if (taskTimeSpan) {
                        taskTimeSpan.textContent = formatTime(tasks[taskIndex].trackedTime);
                    }

                    stopGlobalTimer(); // Stop the interval

                    currentlyTrackingTaskId = null;
                    trackingStartTime = null;

                    if (shouldSaveState) saveState(); // Save updated tracked time and cleared tracking state
                    showNotification(`Timer paused for "${tasks[taskIndex].title}". Total: ${formatTime(tasks[taskIndex].trackedTime)}`, "info");

                } else {
                     // Task not found, clear state anyway
                     stopGlobalTimer();
                     currentlyTrackingTaskId = null;
                     trackingStartTime = null;
                     if (shouldSaveState) saveState();
                }
                 updateGlobalTimerDisplay(0); // Reset header timer display after pause
            };

            const handleTimeTrackerToggle = (taskId) => {
                if (currentlyTrackingTaskId === taskId) {
                    pauseTimeTracker(taskId);
                } else {
                    startTimeTracker(taskId);
                }
            };


            // --- Initialization ---
            const init = () => {
                // Event Listeners
                loginForm.addEventListener('submit', handleLoginFormSubmit);
                logoutBtn.addEventListener('click', handleLogout);
                themeToggleBtn.addEventListener('click', toggleTheme);
                addTaskBtn.addEventListener('click', () => openTaskModal('add'));
                cancelTaskBtn.addEventListener('click', closeTaskModal);
                taskForm.addEventListener('submit', handleTaskFormSubmit);
                addCategoryBtn.addEventListener('click', handleAddCategory);

                // Filters, Sorting, View Switching
                searchInput.addEventListener('input', handleFilterChange);
                filterStatusSelect.addEventListener('change', handleFilterChange);
                filterPrioritySelect.addEventListener('change', handleFilterChange);
                filterCategorySelect.addEventListener('change', handleFilterChange);
                sortTasksSelect.addEventListener('change', handleSortChange);
                listViewBtn.addEventListener('click', () => switchView('list'));
                graphViewBtn.addEventListener('click', () => switchView('graph'));
                document.querySelector('.mb-4.flex.flex-wrap.gap-2').addEventListener('click', handleDateFilterChange); // Delegate date filter clicks


                // Batch Action Listeners
                batchDeleteBtn.addEventListener('click', handleDeleteSelected);
                batchCompleteBtn.addEventListener('click', handleCompleteSelected);
                taskListUl.addEventListener('change', (e) => { // Use event delegation for checkboxes
                    if (e.target.classList.contains('batch-select')) {
                        updateBatchActionBar();
                    }
                });

                // Import/Export
                exportJsonBtn.addEventListener('click', handleExportTasks);
                importJsonInput.addEventListener('change', handleImportTasks);

                // Undo
                undoBtn.addEventListener('click', restoreLastState);

                // Keyboard shortcuts
                document.addEventListener('keydown', handleKeyPress);

                // Modal closing
                taskModal.addEventListener('click', (e) => { if (e.target === taskModal) closeTaskModal(); });

                // Initial Load - Load theme immediately, then show login or load user state
                loadTheme();
                loginScreen.style.display = 'flex'; // Always show login first

            };

            // Start the application
            init();
        });
    </script>

</body>
</html>
