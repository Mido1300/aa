<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Previous HTML and CSS code remains the same -->
</head>
<body>
    <!-- Previous HTML structure remains the same -->
    
    <script>
        // Task class to define task structure
        class Task {
            constructor(id, title, description, dueDate, category, priority, completed = false) {
                this.id = id;
                this.title = title;
                this.description = description;
                this.dueDate = dueDate;
                this.category = category;
                this.priority = priority;
                this.completed = completed;
                this.createdAt = new Date();
            }
        }

        // Main application class
        class TodoApp {
            constructor() {
                this.tasks = [];
                this.categories = ['personal', 'work', 'health'];
                this.selectedTasks = new Set();
                this.currentFilter = 'all';
                this.currentCategory = null;
                this.currentPriority = null;
                this.currentSort = 'date-asc';
                this.isDarkTheme = false;
                
                // DOM elements
                this.elements = {
                    taskList: document.getElementById('task-list'),
                    taskModal: document.getElementById('task-modal'),
                    taskForm: document.getElementById('task-form'),
                    taskTitleInput: document.getElementById('task-title'),
                    taskDescriptionInput: document.getElementById('task-description'),
                    taskDueDateInput: document.getElementById('task-due-date'),
                    taskCategorySelect: document.getElementById('task-category'),
                    taskPrioritySelect: document.getElementById('task-priority') || document.createElement('select'),
                    closeTaskModal: document.getElementById('close-task-modal'),
                    modalTitle: document.getElementById('modal-title'),
                    searchInput: document.getElementById('search-input'),
                    filterList: document.getElementById('filter-list'),
                    categoryList: document.getElementById('category-list'),
                    sortSelect: document.getElementById('sort-tasks'),
                    addTaskBtn: document.getElementById('add-task-btn'),
                    themeToggle: document.getElementById('theme-toggle'),
                    emptyState: document.getElementById('empty-state'),
                    activeFilter: document.getElementById('active-filter'),
                    selectionToolbar: document.getElementById('selection-toolbar'),
                    selectedCount: document.getElementById('selected-count'),
                    completeSelected: document.getElementById('complete-selected'),
                    deleteSelected: document.getElementById('delete-selected'),
                    cancelSelection: document.getElementById('cancel-selection'),
                    importExportBtn: document.getElementById('import-export-btn'),
                    addCategoryBtn: document.getElementById('add-category-btn'),
                    categoryForm: document.getElementById('category-form'),
                    newCategoryInput: document.getElementById('new-category-input'),
                    saveCategoryBtn: document.getElementById('save-category-btn'),
                    statTotal: document.getElementById('stat-total'),
                    statCompleted: document.getElementById('stat-completed'),
                    statPending: document.getElementById('stat-pending'),
                    statOverdue: document.getElementById('stat-overdue')
                };

                this.init();
            }

            init() {
                this.loadTasks();
                this.setupEventListeners();
                this.updateCategorySelect();
                this.renderTasks();
                this.updateStats();
                this.setupKeyboardShortcuts();
                this.checkDueDates();
            }

            setupEventListeners() {
                // Task form submission
                this.elements.taskForm.addEventListener('submit', (e) => this.handleTaskSubmit(e));

                // Modal controls
                this.elements.addTaskBtn.addEventListener('click', () => this.openTaskModal());
                this.elements.closeTaskModal.addEventListener('click', () => this.closeTaskModal());

                // Search
                this.elements.searchInput.addEventListener('input', () => this.renderTasks());

                // Filters
                this.elements.filterList.addEventListener('click', (e) => this.handleFilterClick(e));
                this.elements.categoryList.addEventListener('click', (e) => this.handleCategoryClick(e));

                // Sorting
                this.elements.sortSelect.addEventListener('change', () => {
                    this.currentSort = this.elements.sortSelect.value;
                    this.renderTasks();
                });

                // Theme toggle
                this.elements.themeToggle.addEventListener('click', () => this.toggleTheme());

                // Batch actions
                this.elements.completeSelected.addEventListener('click', () => this.completeSelectedTasks());
                this.elements.deleteSelected.addEventListener('click', () => this.deleteSelectedTasks());
                this.elements.cancelSelection.addEventListener('click', () => this.clearSelection());

                // Import/Export
                this.elements.importExportBtn.addEventListener('click', () => this.handleImportExport());

                // Category management
                this.elements.addCategoryBtn.addEventListener('click', () => {
                    this.elements.categoryForm.style.display = 'flex';
                    this.elements.newCategoryInput.focus();
                });
                this.elements.saveCategoryBtn.addEventListener('click', () => this.addCategory());
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'n') {
                        e.preventDefault();
                        this.openTaskModal();
                    }
                    if (e.key === 'Escape' && this.elements.taskModal.classList.contains('open')) {
                        this.closeTaskModal();
                    }
                    if (e.ctrlKey && e.key === 's') {
                        e.preventDefault();
                        this.showNotification('Tasks saved!', 'success');
                    }
                });
            }

            loadTasks() {
                const savedTasks = localStorage.getItem('tasks');
                if (savedTasks) {
                    this.tasks = JSON.parse(savedTasks).map(task => ({
                        ...task,
                        dueDate: task.dueDate ? new Date(task.dueDate) : null,
                        createdAt: new Date(task.createdAt)
                    }));
                } else {
                    // Sample tasks
                    this.tasks = [
                        new Task(1, 'Buy groceries', 'Purchase milk, eggs, and bread from the supermarket', new Date('2025-04-18'), 'personal', 'high'),
                        new Task(2, 'Finish project report', 'Complete the final report for the React project', new Date('2025-04-20'), 'work', 'medium'),
                        new Task(3, 'Schedule dentist appointment', 'Call the clinic to set up a routine check-up', new Date('2025-04-22'), 'health', 'low')
                    ];
                }

                const savedCategories = localStorage.getItem('categories');
                if (savedCategories) {
                    this.categories = JSON.parse(savedCategories);
                }
            }

            saveTasks() {
                localStorage.setItem('tasks', JSON.stringify(this.tasks));
                localStorage.setItem('categories', JSON.stringify(this.categories));
            }

            openTaskModal(task = null) {
                this.elements.taskModal.classList.add('open');
                this.elements.modalTitle.textContent = task ? 'Edit Task' : 'Add New Task';
                
                if (task) {
                    this.elements.taskForm.querySelector('#task-id').value = task.id;
                    this.elements.taskTitleInput.value = task.title;
                    this.elements.taskDescriptionInput.value = task.description;
                    this.elements.taskDueDateInput.value = task.dueDate ? task.dueDate.toISOString().split('T')[0] : '';
                    this.elements.taskCategorySelect.value = task.category;
                    this.elements.taskPrioritySelect.value = task.priority;
                } else {
                    this.elements.taskForm.reset();
                    this.elements.taskForm.querySelector('#task-id').value = '';
                }
            }

            closeTaskModal() {
                this.elements.taskModal.classList.remove('open');
                this.elements.taskForm.reset();
            }

            handleTaskSubmit(e) {
                e.preventDefault();
                const id = this.elements.taskForm.querySelector('#task-id').value;
                const taskData = {
                    title: this.elements.taskTitleInput.value,
                    description: this.elements.taskDescriptionInput.value,
                    dueDate: this.elements.taskDueDateInput.value ? new Date(this.elements.taskDueDateInput.value) : null,
                    category: this.elements.taskCategorySelect.value,
                    priority: this.elements.taskPrioritySelect.value || 'low'
                };

                if (id) {
                    const taskIndex = this.tasks.findIndex(task => task.id == id);
                    this.tasks[taskIndex] = { ...this.tasks[taskIndex], ...taskData };
                    this.showNotification('Task updated successfully!', 'success');
                } else {
                    const newTask = new Task(
                        Date.now(),
                        taskData.title,
                        taskData.description,
                        taskData.dueDate,
                        taskData.category,
                        taskData.priority
                    );
                    this.tasks.push(newTask);
                    this.showNotification('Task added successfully!', 'success');
                }

                this.saveTasks();
                this.closeTaskModal();
                this.renderTasks();
                this.updateStats();
            }

            renderTasks() {
                this.elements.taskList.innerHTML = '';
                let filteredTasks = this.filterTasks();
                filteredTasks = this.sortTasks(filteredTasks);

                if (filteredTasks.length === 0) {
                    this.elements.emptyState.style.display = 'block';
                    return;
                }

                this.elements.emptyState.style.display = 'none';

                filteredTasks.forEach(task => {
                    const taskElement = this.createTaskElement(task);
                    this.elements.taskList.appendChild(taskElement);
                });

                this.updateTaskCounts();
                this.setupDragAndDrop();
            }

            createTaskElement(task) {
                const li = document.createElement('li');
                li.className = `task-item ${task.priority} ${task.completed ? 'completed' : ''}`;
                li.dataset.id = task.id;
                li.draggable = true;

                li.innerHTML = `
                    <div class="task-content">
                        <div class="task-header">
                            <input type="checkbox" class="task-checkbox" ${this.selectedTasks.has(task.id) ? 'checked' : ''}>
                            <span class="task-title">${task.title}</span>
                            <span class="badge badge-${task.priority}">${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}</span>
                        </div>
                        <div class="task-description">${task.description || ''}</div>
                        <div class="task-meta">
                            ${task.dueDate ? `<span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 4h-1V3a1 1 0 0 0-2 0v1H8V3a1 1 0 0 0-2 0v1H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V10h14v10zM5 8V6h14v2H5zm7 6a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm0 4a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm4-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm0 4a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-8-4a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm0 4a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/></svg>${task.dueDate.toLocaleDateString()}</span>` : ''}
                            <span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8zm4-9h-3V8a1 1 0 0 0-2 0v4a1 1 0 0 0 1 1h4a1 1 0 0 0 0-2z"/></svg>${task.category}</span>
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn btn-icon edit-task">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a1.414 1.414 0 0 0 0-2l-2-2a1.414 1.414 0 0 0-2 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                        </button>
                        <button class="btn btn-icon delete-task">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                        </button>
                    </div>
                `;

                // Event listeners for task actions
                li.querySelector('.task-checkbox').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.selectedTasks.add(task.id);
                    } else {
                        this.selectedTasks.delete(task.id);
                    }
                    this.updateSelectionToolbar();
                });

                li.querySelector('.edit-task').addEventListener('click', () => this.openTaskModal(task));
                
                li.querySelector('.delete-task').addEventListener('click', () => {
                    this.deleteTask(task.id);
                    this.showNotification('Task deleted! <button class="undo-btn">Undo</button>', 'success');
                    const deletedTask = task;
                    setTimeout(() => {
                        if (this.tasks.find(t => t.id === deletedTask.id)) return;
                        this.tasks = this.tasks.filter(t => t.id !== deletedTask.id);
                        this.saveTasks();
                        this.renderTasks();
                    }, 3000);
                    this.tasks.push(deletedTask); // Temporary for undo
                });

                return li;
            }

            filterTasks() {
                let filteredTasks = [...this.tasks];
                const searchTerm = this.elements.searchInput.value.toLowerCase();

                // Apply search
                if (searchTerm) {
                    filteredTasks = filteredTasks.filter(task =>
                        task.title.toLowerCase().includes(searchTerm) ||
                        task.description?.toLowerCase().includes(searchTerm)
                    );
                }

                // Apply filters
                if (this.currentFilter !== 'all') {
                    filteredTasks = filteredTasks.filter(task => {
                        if (this.currentFilter === 'active') return !task.completed;
                        if (this.currentFilter === 'completed') return task.completed;
                        if (this.currentFilter === 'today') {
                            const today = new Date();
                            return task.dueDate && task.dueDate.toDateString() === today.toDateString();
                        }
                        if (this.currentFilter === 'this-week') {
                            const today = new Date();
                            const weekEnd = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
                            return task.dueDate && task.dueDate >= today && task.dueDate <= weekEnd;
                        }
                        if (this.currentFilter === 'this-month') {
                            const today = new Date();
                            return task.dueDate && task.dueDate.getMonth() === today.getMonth();
                        }
                        return true;
                    });
                }

                // Apply category filter
                if (this.currentCategory) {
                    filteredTasks = filteredTasks.filter(task => task.category === this.currentCategory);
                }

                // Apply priority filter
                if (this.currentPriority) {
                    filteredTasks = filteredTasks.filter(task => task.priority === this.currentPriority);
                }

                return filteredTasks;
            }

            sortTasks(tasks) {
                return tasks.sort((a, b) => {
                    switch (this.currentSort) {
                        case 'date-asc':
                            return (a.dueDate || new Date(9999, 11, 31)) - (b.dueDate || new Date(9999, 11, 31));
                        case 'date-desc':
                            return (b.dueDate || new Date(0)) - (a.dueDate || new Date(0));
                        case 'priority-desc':
                            const priorityOrder = { high: 3, medium: 2, low: 1 };
                            return priorityOrder[b.priority] - priorityOrder[a.priority];
                        case 'priority-asc':
                            const priorityOrderAsc = { high: 1, medium: 2, low: 3 };
                            return priorityOrderAsc[b.priority] - priorityOrderAsc[a.priority];
                        case 'name-asc':
                            return a.title.localeCompare(b.title);
                        case 'name-desc':
                            return b.title.localeCompare(a.title);
                        default:
                            return 0;
                    }
                });
            }

            handleFilterClick(e) {
                const filterItem = e.target.closest('.filter-item');
                if (!filterItem) return;

                this.currentFilter = filterItem.dataset.filter;
                this.currentCategory = null;
                this.currentPriority = null;

                this.updateActiveFilter(filterItem);
                this.renderTasks();
            }

            handleCategoryClick(e) {
                const categoryItem = e.target.closest('.category-item');
                if (!categoryItem) return;

                this.currentCategory = categoryItem.dataset.category;
                this.currentFilter = 'all';
                this.currentPriority = null;

                this.updateActiveFilter(categoryItem);
                this.renderTasks();
            }

            updateActiveFilter(item) {
                document.querySelectorAll('.filter-item, .category-item').forEach(el => el.classList.remove('active'));
                item.classList.add('active');
                this.elements.activeFilter.querySelector('h2').textContent = item.querySelector('span').textContent;
            }

            updateTaskCounts() {
                const counts = {
                    all: this.tasks.length,
                    active: this.tasks.filter(t => !t.completed).length,
                    completed: this.tasks.filter(t => t.completed).length,
                    today: this.tasks.filter(t => t.dueDate && t.dueDate.toDateString() === new Date().toDateString()).length,
                    week: this.tasks.filter(t => {
                        const today = new Date();
                        const weekEnd = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
                        return t.dueDate && t.dueDate >= today && t.dueDate <= weekEnd;
                    }).length,
                    month: this.tasks.filter(t => t.dueDate && t.dueDate.getMonth() === new Date().getMonth()).length,
                    high: this.tasks.filter(t => t.priority === 'high').length,
                    medium: this.tasks.filter(t => t.priority === 'medium').length,
                    low: this.tasks.filter(t => t.priority === 'low').length
                };

                this.categories.forEach(category => {
                    counts[category] = this.tasks.filter(t => t.category === category).length;
                });

                Object.keys(counts).forEach(key => {
                    const element = document.getElementById(`count-${key}`);
                    if (element) element.textContent = counts[key];
                });
            }

            updateStats() {
                this.elements.statTotal.textContent = this.tasks.length;
                this.elements.statCompleted.textContent = this.tasks.filter(t => t.completed).length;
                this.elements.statPending.textContent = this.tasks.filter(t => !t.completed).length;
                this.elements.statOverdue.textContent = this.tasks.filter(t => t.dueDate && t.dueDate < new Date() && !t.completed).length;
            }

            setupDragAndDrop() {
                const taskItems = this.elements.taskList.querySelectorAll('.task-item');
                taskItems.forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        item.classList.add('dragging');
                        e.dataTransfer.setData('text/plain', item.dataset.id);
                    });

                    item.addEventListener('dragend', () => {
                        item.classList.remove('dragging');
                    });

                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                    });

                    item.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const draggedId = e.dataTransfer.getData('text/plain');
                        const targetId = item.dataset.id;
                        const draggedTask = this.tasks.find(t => t.id == draggedId);
                        const targetTask = this.tasks.find(t => t.id == targetId);

                        const draggedIndex = this.tasks.indexOf(draggedTask);
                        const targetIndex = this.tasks.indexOf(targetTask);

                        this.tasks.splice(draggedIndex, 1);
                        this.tasks.splice(targetIndex, 0, draggedTask);

                        this.saveTasks();
                        this.renderTasks();
                    });
                });
            }

            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                document.body.classList.toggle('dark-theme');
                this.elements.themeToggle.querySelector('.light-icon').style.display = this.isDarkTheme ? 'none' : 'block';
                this.elements.themeToggle.querySelector('.dark-icon').style.display = this.isDarkTheme ? 'block' : 'none';
            }

            showNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type} show`;
                notification.innerHTML = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => notification.remove(), 300);
                }, 3000);

                const undoBtn = notification.querySelector('.undo-btn');
                if (undoBtn) {
                    undoBtn.addEventListener('click', () => {
                        this.renderTasks();
                        notification.remove();
                    });
                }
            }

            updateSelectionToolbar() {
                this.elements.selectedCount.textContent = this.selectedTasks.size;
                this.elements.selectionToolbar.classList.toggle('show', this.selectedTasks.size > 0);
            }

            completeSelectedTasks() {
                this.selectedTasks.forEach(id => {
                    const task = this.tasks.find(t => t.id == id);
                    if (task) task.completed = true;
                });
                this.selectedTasks.clear();
                this.saveTasks();
                this.renderTasks();
                this.updateStats();
                this.updateSelectionToolbar();
                this.showNotification('Selected tasks marked as complete!', 'success');
            }

            deleteSelectedTasks() {
                const deletedTasks = [];
                this.selectedTasks.forEach(id => {
                    const task = this.tasks.find(t => t.id == id);
                    if (task) deletedTasks.push(task);
                });

                this.tasks = this.tasks.filter(t => !this.selectedTasks.has(t.id));
                this.selectedTasks.clear();
                this.saveTasks();
                this.renderTasks();
                this.updateStats();
                this.updateSelectionToolbar();
                this.showNotification('Selected tasks deleted! <button class="undo-btn">Undo</button>', 'success');

                setTimeout(() => {
                    if (this.tasks.some(t => deletedTasks.includes(t))) return;
                    this.tasks = this.tasks.filter(t => !deletedTasks.includes(t));
                    this.saveTasks();
                    this.renderTasks();
                }, 3000);

                this.tasks.push(...deletedTasks); // Temporary for undo
            }

            clearSelection() {
                this.selectedTasks.clear();
                this.updateSelectionToolbar();
                this.renderTasks();
            }

            handleImportExport() {
                const action = prompt('Type "export" to export tasks or "import" to import tasks:');
                if (action === 'export') {
                    const dataStr = JSON.stringify(this.tasks);
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    const exportFileDefaultName = 'tasks.json';

                    const linkElement = document.createElement('a');
                    linkElement.setAttribute('href', dataUri);
                    linkElement.setAttribute('download', exportFileDefaultName);
                    linkElement.click();
                    this.showNotification('Tasks exported successfully!', 'success');
                } else if (action === 'import') {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const importedTasks = JSON.parse(event.target.result);
                                this.tasks = importedTasks.map(task => ({
                                    ...task,
                                    dueDate: task.dueDate ? new Date(task.dueDate) : null,
                                    createdAt: new Date(task.createdAt)
                                }));
                                this.saveTasks();
                                this.renderTasks();
                                this.updateStats();
                                this.showNotification('Tasks imported successfully!', 'success');
                            } catch (error) {
                                this.showNotification('Error importing tasks!', 'error');
                            }
                        };
                        reader.readAsText(file);
                    };
                    input.click();
                }
            }

            addCategory() {
                const categoryName = this.elements.newCategoryInput.value.trim().toLowerCase();
                if (!categoryName || this.categories.includes(categoryName)) {
                    this.showNotification('Invalid or duplicate category!',you are here: /home/user/samplecode/html_css_js_todo_app/index.htmlcategory already exists!', 'error');
                    return;
                }

                this.categories.push(categoryName);
                this.elements.categoryForm.style.display = 'none';
                this.elements.newCategoryInput.value = '';
                this.updateCategoryList();
                this.updateCategorySelect();
                this.saveTasks();
                this.showNotification('Category added successfully!', 'success');
            }

            updateCategoryList() {
                this.elements.categoryList.innerHTML = this.categories.map(category => `
                    <li class="category-item" data-category="${category}">
                        <span>${category.charAt(0).toUpperCase() + category.slice(1)}</span>
                        <span class="task-count" id="count-${category}">0</span>
                    </li>
                `).join('');
            }

            updateCategorySelect() {
                this.elements.taskCategorySelect.innerHTML = this.categories.map(category => `
                    <option value="${category}">${category.charAt(0).toUpperCase() + category.slice(1)}</option>
                `).join('');
            }

            checkDueDates() {
                const today = new Date();
                this.tasks.forEach(task => {
                    if (task.dueDate && task.dueDate < today && !task.completed) {
                        this.showNotification(`Task "${task.title}" is overdue!`, 'warning');
                    }
                });
            }

            deleteTask(taskId) {
                this.tasks = this.tasks.filter(task => task.id != taskId);
                this.saveTasks();
                this.renderTasks();
                this.updateStats();
            }
        }

        // Initialize the app
        const app = new TodoApp();

        // Add priority select to task form (since it wasn't in the original HTML)
        const priorityGroup = document.createElement('div');
        priorityGroup.className = 'form-group';
        priorityGroup.innerHTML = `
            <label for="task-priority" class="form-label">Priority</label>
            <select id="task-priority" class="form-select" required>
                <option value="low">Low</option>
                <option value="medium">Medium</option>
                <option value="high">High</option>
            </select>
        `;
        document.getElementById('task-form').insertBefore(priorityGroup, document.getElementById('task-form').lastElementChild);
    </script>
</body>
</html>
