<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced To-Do App</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6a040f">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
        :root {
            /* --- Light Mode --- */
            --lm-page-bg-start: #f8f9fa; /* Lighter Background */
            --lm-page-bg-end: #e9ecef;   /* Slightly Darker Background */
            --lm-component-bg: #ffffff; /* White component background */
            --lm-text: #212529;     /* Dark text */
            --lm-muted-text: #6c757d; /* Grayish text */
            --lm-border: #dee2e6;   /* Light gray border */
            --lm-input-bg: #ffffff;  /* White input bg */
            --lm-input-border: #ced4da; /* Standard input border */
            --lm-shadow-color: rgba(0, 0, 0, 0.1); /* Lighter shadow */
            --lm-accent-color: #9d0208; /* Dark Red Accent */
            --lm-accent-hover: #6a040f; /* Darker Red Hover */
            --lm-priority-high: #dc3545;
            --lm-priority-medium: #ffc107;
            --lm-priority-low: #198754;
            --lm-completed-bg: #e9f5e9;
            --lm-overdue-bg: #fdecec;
            --lm-subtask-bg: #f1f3f5; /* Light background for subtasks */

            /* --- Dark Mode --- */
            --dm-page-bg-start: #212529; /* Dark Gray */
            --dm-page-bg-end: #343a40;   /* Slightly Lighter Dark Gray */
            --dm-component-bg: #495057; /* Darker component background */
            --dm-text: #f8f9fa;     /* Light text */
            --dm-muted-text: #adb5bd; /* Lighter grayish text */
            --dm-border: #6c757d;   /* Gray border */
            --dm-input-bg: #6c757d;  /* Gray input bg */
            --dm-input-border: #adb5bd; /* Lighter gray input border */
            --dm-shadow-color: rgba(255, 255, 255, 0.05); /* Lighter shadow */
            --dm-accent-color: #e85d04; /* Orange Accent */
            --dm-accent-hover: #dc2f02; /* Darker Orange Hover */
            --dm-priority-high: #f07167;
            --dm-priority-medium: #ffb703;
            --dm-priority-low: #84a98c;
            --dm-completed-bg: #3a5a40;
            --dm-overdue-bg: #5e2129;
            --dm-subtask-bg: #525860; /* Darker background for subtasks */
        }

        /* --- General Styles --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, var(--page-bg-start), var(--page-bg-end));
            color: var(--text);
            transition: background 0.3s ease, color 0.3s ease;
            display: flex;
            min-height: 100vh;
            font-size: 16px; /* Base font size */
        }

        /* --- Theme Variables Application --- */
        body {
            --page-bg-start: var(--lm-page-bg-start);
            --page-bg-end: var(--lm-page-bg-end);
            --component-bg: var(--lm-component-bg);
            --text: var(--lm-text);
            --muted-text: var(--lm-muted-text);
            --border: var(--lm-border);
            --input-bg: var(--lm-input-bg);
            --input-border: var(--lm-input-border);
            --shadow-color: var(--lm-shadow-color);
            --accent-color: var(--lm-accent-color);
            --accent-hover: var(--lm-accent-hover);
            --priority-high: var(--lm-priority-high);
            --priority-medium: var(--lm-priority-medium);
            --priority-low: var(--lm-priority-low);
            --completed-bg: var(--lm-completed-bg);
            --overdue-bg: var(--lm-overdue-bg);
            --subtask-bg: var(--lm-subtask-bg);
        }

        body.dark-mode {
            --page-bg-start: var(--dm-page-bg-start);
            --page-bg-end: var(--dm-page-bg-end);
            --component-bg: var(--dm-component-bg);
            --text: var(--dm-text);
            --muted-text: var(--dm-muted-text);
            --border: var(--dm-border);
            --input-bg: var(--dm-input-bg);
            --input-border: var(--dm-input-border);
            --shadow-color: var(--dm-shadow-color);
            --accent-color: var(--dm-accent-color);
            --accent-hover: var(--dm-accent-hover);
            --priority-high: var(--dm-priority-high);
            --priority-medium: var(--dm-priority-medium);
            --priority-low: var(--dm-priority-low);
            --completed-bg: var(--dm-completed-bg);
            --overdue-bg: var(--dm-overdue-bg);
            --subtask-bg: var(--dm-subtask-bg);
        }

        /* --- Layout --- */
        .container {
            display: flex;
            width: 100%;
            max-width: 1800px; /* Increased max-width for wider screens */
            margin: 1rem auto;
            background-color: var(--component-bg);
            border-radius: 12px;
            box-shadow: 0 8px 25px var(--shadow-color);
            overflow: hidden; /* Contain children */
            transition: background-color 0.3s ease;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 250px; /* Slightly wider sidebar */
            background-color: var(--accent-color);
            color: #fff;
            padding: 1.5rem 1rem;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s ease, width 0.3s ease;
            flex-shrink: 0;
        }

        .sidebar h1 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .sidebar h1 i { font-size: 1.3em; }

        .sidebar-menu { list-style: none; margin-bottom: auto; /* Pushes footer down */ }
        .sidebar-menu li a, .sidebar-menu li button {
            color: #fff;
            text-decoration: none;
            display: flex; /* Use flexbox */
            align-items: center; /* Vertically align icon and text */
            gap: 0.8rem; /* Space between icon and text */
            padding: 0.8rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 6px;
            transition: background-color 0.2s ease, padding-left 0.2s ease;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            font-size: 1rem;
            cursor: pointer;
        }
        .sidebar-menu li a i, .sidebar-menu li button i { width: 20px; text-align: center; } /* Fixed width for icons */

        .sidebar-menu li a:hover, .sidebar-menu li button:hover,
        .sidebar-menu li a.active, .sidebar-menu li button.active {
            background-color: rgba(255, 255, 255, 0.2);
            padding-left: 1.2rem; /* Indent on hover/active */
        }

        .sidebar-footer { margin-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 1rem; }

        #total-timer-display {
            background-color: rgba(0,0,0,0.2);
            padding: 0.6rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: default;
            display: flex; /* Use flex for icon alignment */
            align-items: center;
            justify-content: center; /* Center content */
            gap: 0.5rem; /* Space between icon and text */
        }
        #total-timer-display i { flex-shrink: 0; } /* Prevent icon shrinking */

        /* --- Main Content --- */
        .main-content {
            flex-grow: 1;
            padding: 1.5rem 2rem;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Allows content to scroll if needed */
        }

        .main-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 1rem;
            gap: 1rem;
        }

        .main-header h2 { color: var(--accent-color); font-size: 1.8rem; margin: 0;}

        .header-controls { display: flex; align-items: center; gap: 0.8rem; position: relative; }
        .header-controls button {
            background: none;
            border: none;
            color: var(--muted-text);
            font-size: 1.3rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: background-color 0.2s ease, color 0.2s ease;
            width: 40px;
            height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .header-controls button:hover { background-color: var(--input-bg); color: var(--accent-color); }

        /* --- Notifications --- */
        .notification-list {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background-color: var(--component-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 4px 15px var(--shadow-color);
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            padding: 0.5rem 0;
        }
        .notification-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .notification-item:last-child { border-bottom: none; }
        .notification-item.info { border-left: 4px solid #0dcaf0; }
        .notification-item.success { border-left: 4px solid #198754; }
        .notification-item.warning { border-left: 4px solid #ffc107; }
        .notification-item.error { border-left: 4px solid #dc3545; }
        .notification-item .msg { flex-grow: 1; margin-right: 0.5rem;}
        .notification-item .time { font-size: 0.75rem; color: var(--muted-text); flex-shrink: 0;}
        .notification-badge {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--lm-priority-high);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transform: translate(30%, -30%); /* Adjust position */
        }
        .notification-btn-wrapper { position: relative; }


        /* --- Task Action Buttons (Moved Section) --- */
        .task-actions-section {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 1.5rem; /* Space below actions */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .task-actions-section button,
        .task-actions-section .file-input-label button { /* Style button inside label too */
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-actions-section button:hover,
        .task-actions-section .file-input-label button:hover {
            background-color: var(--accent-hover);
        }
        .task-actions-section button:active,
        .task-actions-section .file-input-label button:active {
            transform: scale(0.98);
        }
        .task-actions-section button i,
        .task-actions-section .file-input-label button i {
            font-size: 1.1em;
        }

        .file-input-label input[type="file"] { display: none; } /* Hide default file input */


        /* --- Task Filters/Layouts (Today, Week, etc.) --- */
        .task-layouts {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .task-layouts button {
            background-color: var(--input-bg);
            color: var(--muted-text);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 20px; /* Pill shape */
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            font-size: 0.9rem;
        }
        .task-layouts button.active, .task-layouts button:hover {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        /* --- View Switcher --- */
        .view-switcher {
            display: flex;
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: hidden; /* Clip children to rounded corners */
            margin-bottom: 1.5rem;
        }
        .view-switcher button {
            background-color: var(--input-bg);
            color: var(--muted-text);
            border: none;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            font-size: 0.9rem;
            flex-grow: 1; /* Make buttons share space */
        }
        .view-switcher button:first-child { border-right: 1px solid var(--border); }
        .view-switcher button.active, .view-switcher button:hover {
            background-color: var(--accent-color);
            color: white;
        }
        .view-switcher button i { margin-right: 0.5rem; }

        /* --- Task Views Container --- */
        .task-views {
            position: relative; /* For absolute positioning of views */
            flex-grow: 1;
            overflow: hidden; /* Hide the non-active view */
            min-height: 300px; /* Ensure container has some height */
        }

        .task-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 1;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            z-index: 1; /* Base layer */
            overflow-y: auto; /* Allow scrolling within the view if needed */
        }

        .task-view.hidden-view {
            opacity: 0;
            transform: translateX(100%); /* Slide out effect */
            pointer-events: none; /* Prevent interaction */
            z-index: 0;
        }

        #list-view.hidden-view {
             transform: translateX(-100%); /* Slide out other direction */
        }


        /* --- Task List --- */
        #task-list { list-style: none; }
        .task-item {
            background-color: var(--component-bg);
            border: 1px solid var(--border);
            border-left: 5px solid var(--accent-color); /* Default border color */
            border-radius: 8px;
            margin-bottom: 1rem;
            padding: 1rem 1.2rem;
            display: flex;
            align-items: flex-start; /* Align items to the top */
            gap: 1rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.2s ease;
            position: relative; /* For selection overlay */
            cursor: pointer; /* Indicate clickable */
        }
        .task-item:hover { box-shadow: 0 4px 10px var(--shadow-color); }

        .task-item.completed {
            background-color: var(--completed-bg);
            border-left-color: var(--lm-priority-low); /* Green */
            opacity: 0.7;
        }
        .task-item.completed .task-details h3 { text-decoration: line-through; color: var(--muted-text); }
        .task-item.overdue {
             background-color: var(--overdue-bg);
             border-left-color: var(--lm-priority-high); /* Red */
        }
        .task-item.priority-High { border-left-color: var(--priority-high); }
        .task-item.priority-Medium { border-left-color: var(--priority-medium); }
        .task-item.priority-Low { border-left-color: var(--priority-low); }

        /* Selection */
        .task-selection { display: flex; align-items: center; margin-top: 5px; /* Align checkbox */ }
        .task-selection input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }

        .task-details { flex-grow: 1; }
        .task-details h3 { margin-bottom: 0.3rem; font-size: 1.1rem; font-weight: 600; }
        .task-info { display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; font-size: 0.85rem; color: var(--muted-text); margin-bottom: 0.5rem; }
        .task-info span { display: inline-flex; align-items: center; gap: 0.3rem; }
        .task-info .priority-tag { padding: 0.1rem 0.5rem; border-radius: 4px; color: white; font-weight: 500; }
        .priority-tag.High { background-color: var(--priority-high); }
        .priority-tag.Medium { background-color: var(--priority-medium); }
        .priority-tag.Low { background-color: var(--priority-low); }

        .task-description { font-size: 0.95rem; margin-bottom: 0.8rem; color: var(--text); word-break: break-word; }

        /* Subtasks */
        .subtasks-section { margin-top: 0.8rem; }
        .subtasks-toggle { font-weight: bold; cursor: pointer; font-size: 0.9rem; color: var(--accent-color); margin-bottom: 0.3rem; display: inline-flex; align-items: center; gap: 0.3rem; }
        .subtasks-toggle i { transition: transform 0.2s ease; }
        .subtasks-toggle.open i { transform: rotate(90deg); }
        .subtasks-list {
            list-style: none;
            padding-left: 1rem;
            margin-top: 0.5rem;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .subtasks-list.open { max-height: 200px; /* Adjust as needed */ overflow-y: auto; }
        .subtask-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.3rem 0.5rem;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
            background-color: var(--subtask-bg);
            border-radius: 4px;
        }
        .subtask-item input[type="checkbox"] { width: 15px; height: 15px; flex-shrink: 0; }
        .subtask-item span { flex-grow: 1; word-break: break-word; }
        .subtask-item.completed span { text-decoration: line-through; opacity: 0.7; }


        .task-controls {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            align-items: flex-end; /* Align buttons to the right */
            gap: 0.5rem;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .task-controls button {
            background: none;
            border: 1px solid transparent; /* Placeholder for consistent size */
            color: var(--muted-text);
            font-size: 1rem; /* Smaller icons */
            cursor: pointer;
            padding: 0.4rem; /* Smaller padding */
            border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            width: 32px; height: 32px; /* Fixed size */
            display: inline-flex; align-items: center; justify-content: center;
        }
        .task-controls button:hover { background-color: var(--input-bg); color: var(--accent-color); border-color: var(--border); }
        .task-controls .timer-btn.active { color: var(--lm-priority-high); background-color: var(--input-bg); border-color: var(--border); }

        /* Timer Display in Task */
        .task-timer-display {
            font-size: 0.8rem;
            color: var(--muted-text);
            margin-top: 0.3rem; /* Space below buttons */
            text-align: right;
            min-width: 60px; /* Ensure space */
            font-variant-numeric: tabular-nums; /* Keep time width consistent */
        }

        /* Batch Actions Bar */
        #batch-actions-bar {
            display: none; /* Hidden by default */
            position: sticky;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--accent-color);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 500;
            align-items: center;
            gap: 1rem;
        }
         #batch-actions-bar.visible { display: flex; }
        #batch-actions-bar span { font-weight: 500; }
        #batch-actions-bar button {
            background-color: rgba(255, 255, 255, 0.8);
            color: var(--accent-color);
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }
        #batch-actions-bar button:hover { background-color: white; }


        /* --- Graph View --- */
        #graph-view {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%; /* Take full height of container */
            padding: 1rem; /* Add padding */
        }
        #task-chart-container { /* Add a container */
             position: relative;
             width: 100%;
             max-width: 450px; /* Max width */
             height: auto; /* Auto height */
             aspect-ratio: 1 / 1; /* Make it square-ish */
             max-height: 400px;
        }
        #task-chart {
            display: block; /* Remove extra space below canvas */
            width: 100% !important; /* Force Chart.js to fill container */
            height: 100% !important;
        }


        /* --- Modals --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1001; /* Sit on top */
            left: 0; top: 0;
            width: 100%; height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            align-items: center;
            justify-content: center;
            padding: 1rem; /* Add padding for smaller screens */
        }
        .modal-content {
            background-color: var(--component-bg);
            margin: auto;
            padding: 25px 30px;
            border: 1px solid var(--border);
            width: 90%;
            max-width: 550px; /* Limit max width */
            border-radius: 10px;
            box-shadow: 0 5px 20px var(--shadow-color);
            position: relative;
            animation: slideIn 0.3s ease-out;
            max-height: 90vh; /* Limit height */
            display: flex; /* Use flex for structure */
            flex-direction: column;
        }
        .modal-body {
            overflow-y: auto; /* Allow body to scroll */
            flex-grow: 1; /* Allow body to take available space */
        }

        @keyframes slideIn {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            border-bottom: 1px solid var(--border);
            padding-bottom: 1rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header shrinking */
        }
        .modal-header h2 { color: var(--accent-color); font-size: 1.5rem; margin: 0; }
        .close-btn {
            color: var(--muted-text);
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            background: none; border: none; padding: 0; line-height: 1;
        }
        .close-btn:hover, .close-btn:focus { color: var(--text); }

        .modal-body .form-group { margin-bottom: 1.2rem; }
        .modal-body label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text);
            font-size: 0.95rem;
        }
        .modal-body input[type="text"],
        .modal-body input[type="datetime-local"], /* Note: datetime-local is less user-friendly than flatpickr */
        .modal-body textarea,
        .modal-body select {
            width: 100%;
            padding: 0.7rem 0.9rem;
            border: 1px solid var(--input-border);
            background-color: var(--input-bg);
            color: var(--text);
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .modal-body input[type="text"]:focus,
        .modal-body input[type="datetime-local"]:focus,
        .modal-body textarea:focus,
        .modal-body select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(157, 2, 8, 0.15); /* Adjusted shadow color */
        }
        .modal-body textarea { min-height: 80px; resize: vertical; }

        /* Subtask input in modal */
        #subtasks-container { margin-top: 0.8rem; }
        .subtask-input-group { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; }
        .subtask-input-group input { flex-grow: 1; }
        .subtask-input-group button {
            padding: 0.5rem; font-size: 0.8rem; flex-shrink: 0; line-height: 1;
            background-color: var(--input-bg); border: 1px solid var(--border); border-radius: 4px; cursor: pointer;
            color: var(--text); /* Ensure visible text */
        }
        .subtask-input-group button:hover { background-color: var(--border); }

        #subtasks-modal-list { list-style: none; max-height: 150px; overflow-y: auto; padding: 0.5rem; border: 1px solid var(--border); border-radius: 4px; margin-top: 0.5rem; background-color: var(--subtask-bg); }
        #subtasks-modal-list li { display: flex; justify-content: space-between; align-items: center; padding: 0.3rem 0.5rem; border-bottom: 1px solid var(--border); }
        #subtasks-modal-list li:last-child { border-bottom: none; }
        #subtasks-modal-list span { word-break: break-all; }
        #subtasks-modal-list button { background: none; border: none; color: var(--lm-priority-high); cursor: pointer; padding: 0.2rem; }
        #subtasks-modal-list button:hover { color: var(--accent-hover); }


        .modal-footer {
            text-align: right;
            border-top: 1px solid var(--border);
            padding-top: 1rem;
            margin-top: 1.5rem;
            flex-shrink: 0; /* Prevent footer shrinking */
        }
        .modal-footer button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 0.7rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            font-size: 1rem;
            margin-left: 0.5rem;
        }
        .modal-footer button:hover { background-color: var(--accent-hover); }
        .modal-footer button:active { transform: scale(0.98); }
        .modal-footer button.secondary {
            background-color: var(--input-bg);
            color: var(--muted-text);
            border: 1px solid var(--border);
        }
        .modal-footer button.secondary:hover { background-color: var(--border); }

        /* --- Responsive Design --- */
        @media (max-width: 1200px) {
            .container { margin: 0.5rem; border-radius: 8px; }
            .main-content { padding: 1rem 1.5rem; }
        }

        @media (max-width: 992px) {
            .sidebar {
                width: 60px; /* Collapse sidebar */
                padding: 1.5rem 0.5rem;
                align-items: center;
            }
            .sidebar h1 { font-size: 1.2rem; }
            .sidebar h1 span { display: none; } /* Hide text */
            .sidebar-menu li a span, .sidebar-menu li button span { display: none; } /* Hide text */
            .sidebar-menu li a, .sidebar-menu li button { justify-content: center; padding: 0.8rem 0; }
            .sidebar-menu li a:hover, .sidebar-menu li button:hover,
            .sidebar-menu li a.active, .sidebar-menu li button.active { padding-left: 0; } /* Remove indent */

            #total-timer-display span { display: none; }
            #total-timer-display { padding: 0.6rem 0; font-size: 0.8rem; justify-content: center; }
            #total-timer-display i { margin-right: 0; }

            .sidebar-footer button span { display: none; }

            .main-header h2 { font-size: 1.5rem; }
        }

        @media (max-width: 768px) {
            body { font-size: 15px; display: block; /* Stack container items */ } /* Change flex to block */
            .container { flex-direction: column; margin: 0; border-radius: 0; min-height: 100vh; max-width: 100%; height: 100vh; } /* Ensure container takes full height */
            .sidebar {
                width: 100%; /* Full width */
                height: 60px; /* Fixed height bottom bar */
                flex-direction: row; /* Horizontal layout */
                justify-content: space-around; /* Space items */
                padding: 0 0.5rem; /* Adjust padding */
                order: 2; /* Move sidebar to bottom */
                background-color: var(--component-bg); /* Match main area */
                border-top: 1px solid var(--border);
                box-shadow: 0 -2px 10px var(--shadow-color);
                flex-shrink: 0; /* Prevent shrinking */
                align-items: center; /* Center items vertically */
            }
            .sidebar h1 { display: none; } /* Hide title */
            .sidebar-menu { display: flex; flex-grow: 1; justify-content: space-around; margin-bottom: 0; height: 100%; align-items: center; }
            .sidebar-menu li { margin-bottom: 0; height: 100%; display: flex; align-items: center; }
            .sidebar-menu li a, .sidebar-menu li button {
                flex-direction: column; /* Stack icon and text */
                gap: 0.2rem;
                padding: 0.5rem;
                font-size: 0.7rem; /* Smaller text */
                color: var(--muted-text); /* Match main text color */
                background: none;
                height: 100%; /* Take full height */
                justify-content: center; /* Center content vertically */
                width: auto; /* Allow natural width */
                 border-radius: 0; /* Remove radius */
            }
             .sidebar-menu li a i, .sidebar-menu li button i { width: auto; font-size: 1.2rem; } /* Adjust icon size */
            .sidebar-menu li a:hover, .sidebar-menu li button:hover,
            .sidebar-menu li a.active, .sidebar-menu li button.active {
                 color: var(--accent-color); /* Highlight active */
                 background: none;
                 padding-left: 0.5rem; /* Keep padding consistent */
            }
             .sidebar-footer { display: none; } /* Hide footer in horizontal mode */


            .main-content {
                 padding: 1rem;
                 order: 1;
                 flex-grow: 1; /* Allow main content to fill remaining space */
                 overflow-y: auto; /* Ensure main content scrolls */
                 height: calc(100vh - 60px); /* Adjust height for bottom bar */
             }
            .main-header { margin-bottom: 1rem; padding-bottom: 0.8rem; }
            .main-header h2 { font-size: 1.4rem; }
            .header-controls { gap: 0.5rem; }
            .header-controls button { font-size: 1.1rem; width: 35px; height: 35px; }

            .task-actions-section { gap: 0.5rem; margin-bottom: 1rem; justify-content: center;}
            .task-actions-section button,
            .task-actions-section .file-input-label button { padding: 0.5rem 1rem; font-size: 0.9rem; }

            .task-layouts { gap: 0.3rem; margin-bottom: 1rem; justify-content: center; }
            .task-layouts button { padding: 0.4rem 0.8rem; font-size: 0.85rem; }

            .view-switcher { margin-bottom: 1rem; }

            .task-item { padding: 0.8rem; gap: 0.8rem; }
            .task-details h3 { font-size: 1rem; }
            .task-info { font-size: 0.8rem; }
            .task-description { font-size: 0.9rem; }
            .task-controls { gap: 0.3rem; }
            .task-controls button { width: 30px; height: 30px; font-size: 0.9rem; padding: 0.3rem;}
            .task-timer-display { font-size: 0.75rem; }

            .modal-content { width: 95%; padding: 20px; }
            .modal-header h2 { font-size: 1.3rem; }

            #batch-actions-bar { width: 90%; bottom: calc(60px + 1rem); /* Adjust for bottom nav */ padding: 0.6rem 1rem; font-size: 0.9rem; }
            #batch-actions-bar span { display: none; } /* Hide count text on small screens */
        }

        @media (max-width: 480px) {
            body { font-size: 14px; }
            .main-header { flex-direction: column; align-items: flex-start; gap: 0.5rem; }
            .header-controls { align-self: flex-end; }
            .task-item { flex-direction: column; align-items: stretch; }
            .task-controls { flex-direction: row; justify-content: flex-end; margin-top: 0.8rem; align-items: center; }
            .task-timer-display { text-align: left; margin-top: 0; margin-right: auto; /* Push buttons right */}
            .task-selection { position: absolute; top: 10px; right: 10px; z-index: 5; background: var(--component-bg); padding: 2px;} /* Move checkbox, add bg */
            .task-details { padding-right: 30px; } /* Add padding to avoid overlap with moved checkbox */
            .modal-body { padding-right: 5px; } /* Ensure scrollbar doesn't overlap content */
        }

        /* --- Utility Classes --- */
        .hidden { display: none !important; } /* Force hide */

        /* Flatpickr Theme Adjustments */
        .flatpickr-calendar { background: var(--component-bg); border-radius: 6px; box-shadow: 0 3px 10px var(--shadow-color); border: 1px solid var(--border); z-index: 1050 !important; /* Ensure picker is above modal */}
        .flatpickr-months .flatpickr-month { color: var(--text); fill: var(--text); }
        .flatpickr-months .flatpickr-prev-month, .flatpickr-months .flatpickr-next-month { fill: var(--muted-text); color: var(--muted-text); }
        .flatpickr-months .flatpickr-prev-month:hover, .flatpickr-months .flatpickr-next-month:hover { fill: var(--accent-color); color: var(--accent-color); }
        .flatpickr-current-month .flatpickr-monthDropdown-months, .flatpickr-current-month .numInputWrapper { color: var(--text); }
        .flatpickr-weekdays { background: var(--input-bg); }
        .flatpickr-weekday { color: var(--muted-text); }
        .flatpickr-day { color: var(--text); border: 1px solid transparent; }
        .flatpickr-day:hover { background: var(--input-bg); border-color: var(--border); }
        .flatpickr-day.today { border-color: var(--accent-color); color: var(--accent-color); font-weight: bold;}
        .flatpickr-day.selected, .flatpickr-day.startRange, .flatpickr-day.endRange, .flatpickr-day.selected:hover, .flatpickr-day.startRange:hover, .flatpickr-day.endRange:hover { background: var(--accent-color); border-color: var(--accent-color); color: #fff; }
        .flatpickr-day.disabled, .flatpickr-day.prevMonthDay, .flatpickr-day.nextMonthDay { color: var(--muted-text); opacity: 0.6; cursor: default; }
        .flatpickr-time { border-top: 1px solid var(--border); }
        .flatpickr-time .numInputWrapper span:hover { background: var(--input-bg); }
        .flatpickr-time .flatpickr-am-pm:hover { background: var(--input-bg); }
        .flatpickr-time input { color: var(--text) !important; background: var(--input-bg) !important; } /* Ensure time inputs inherit theme */

        body.dark-mode .flatpickr-current-month .numInputWrapper span { border: 1px solid var(--border); } /* Fix dark mode spinner border */

    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h1><i class="fas fa-check-double"></i> <span>To-Do App</span></h1>
            <ul class="sidebar-menu">
                 <li><a href="#" id="nav-dashboard" class="active"><i class="fas fa-tasks fa-fw"></i> <span>Tasks</span></a></li>
                 <li><a href="#" id="nav-graph"><i class="fas fa-chart-pie fa-fw"></i> <span>Graph</span></a></li>
                <li><a href="#" id="nav-settings" title="Settings (Placeholder)"><i class="fas fa-cog fa-fw"></i> <span>Settings</span></a></li>
                </ul>
            <div class="sidebar-footer">
                 <div id="total-timer-display" title="Total time tracked across all tasks today (Resets daily at 00:00 GMT)">
                     <i class="fas fa-stopwatch"></i> <span>Total Today: 00:00:00</span>
                 </div>
                 <button id="theme-toggle-btn" class="sidebar-footer-btn" title="Toggle light/dark theme">
                     <i class="fas fa-moon"></i> <span>Dark Mode</span>
                 </button>
                <button id="logout-btn" class="sidebar-footer-btn" title="Logout (Placeholder)">
                    <i class="fas fa-sign-out-alt fa-fw"></i> <span>Logout</span>
                </button>
            </div>
        </aside>

        <main class="main-content">
            <header class="main-header">
                <h2 id="main-title">Tasks</h2>
                <div class="header-controls">
                     <div class="notification-btn-wrapper">
                        <button id="notification-btn" aria-label="Notifications" title="Show notifications">
                            <i class="fas fa-bell"></i>
                            <span id="notification-badge" class="notification-badge hidden">0</span>
                        </button>
                        <div id="notification-list" class="notification-list">
                            <div style="padding: 1rem; text-align: center; color: var(--muted-text);">No new notifications</div>
                        </div>
                    </div>
                    <button id="refresh-btn" title="Refresh View"><i class="fas fa-sync-alt"></i></button>
                    </div>
            </header>

             <section class="task-actions-section">
                <button id="add-task-btn" title="Add a new task (Ctrl+Alt+N)"><i class="fas fa-plus"></i> Add Task</button>
                <button id="export-tasks-btn" title="Export tasks to a JSON file"><i class="fas fa-file-export"></i> Export</button>
                <label class="file-input-label">
                     <input type="file" id="import-tasks-input" accept=".json" style="display: none;">
                     <button type="button" onclick="document.getElementById('import-tasks-input').click();" title="Import tasks from a JSON file (replaces current tasks)">
                        <i class="fas fa-file-import"></i> Import
                    </button>
                 </label>
            </section>

            <section class="task-layouts">
                <button class="filter-btn active" data-filter="overall" title="Show all tasks">Overall</button>
                <button class="filter-btn" data-filter="today" title="Show tasks due today">Today</button>
                <button class="filter-btn" data-filter="week" title="Show tasks due this week">This Week</button>
                <button class="filter-btn" data-filter="month" title="Show tasks due this month">This Month</button>
            </section>

             <div class="view-switcher">
                 <button id="list-view-btn" class="active" title="Switch to list view (Ctrl+Alt+L)"><i class="fas fa-list"></i> List View</button>
                 <button id="graph-view-btn" title="Switch to graph view (Ctrl+Alt+G)"><i class="fas fa-chart-pie"></i> Graph View</button>
             </div>

            <div class="task-views">
                <div id="list-view" class="task-view">
                    <ul id="task-list">
                        <li style="text-align: center; color: var(--muted-text); padding: 2rem;">Loading tasks...</li>
                    </ul>
                </div>
                <div id="graph-view" class="task-view hidden-view">
                    <div id="task-chart-container">
                        <canvas id="task-chart"></canvas>
                    </div>
                     <p style="text-align: center; color: var(--muted-text); margin-top: 1rem;">Task status overview</p>
                </div>
            </div>

             <div id="batch-actions-bar">
                <span id="selected-count">0 selected</span>
                <button id="batch-delete-btn" title="Delete selected tasks"><i class="fas fa-trash-alt"></i> Delete</button>
                <button id="batch-complete-btn" title="Mark selected tasks as complete"><i class="fas fa-check-circle"></i> Mark Complete</button>
                <button id="batch-uncomplete-btn" title="Mark selected tasks as incomplete"><i class="fas fa-times-circle"></i> Mark Incomplete</button>
            </div>

        </main>
    </div>

    <div id="task-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Add Task</h2>
                <button class="close-btn" onclick="closeModal(document.getElementById('task-modal'))" aria-label="Close modal">&times;</button>
            </div>
            <form id="task-form">
                <div class="modal-body">
                    <input type="hidden" id="task-id">
                    <div class="form-group">
                        <label for="task-title">Title *</label>
                        <input type="text" id="task-title" placeholder="e.g., Finish project report" required>
                    </div>
                    <div class="form-group">
                        <label for="task-description">Description</label>
                        <textarea id="task-description" placeholder="Add more details..."></textarea>
                    </div>
                     <div class="form-group">
                        <label for="task-category">Category</label>
                        <input type="text" id="task-category" placeholder="e.g., Work, Personal, Study">
                    </div>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <div class="form-group" style="flex: 1 1 180px;">
                            <label for="task-priority">Priority</label>
                            <select id="task-priority">
                                <option value="High">High</option>
                                <option value="Medium" selected>Medium</option>
                                <option value="Low">Low</option>
                            </select>
                        </div>
                        <div class="form-group" style="flex: 1 1 180px;">
                             <label for="task-due-date">Due Date</label>
                             <input type="text" id="task-due-date" placeholder="Select date and time"> </div>
                    </div>
                     <div class="form-group">
                        <label for="task-recurrence">Recurrence</label>
                        <select id="task-recurrence">
                            <option value="none">None</option>
                            <option value="daily">Daily</option>
                            <option value="weekly">Weekly</option>
                            <option value="monthly">Monthly</option>
                        </select>
                    </div>

                    <div class="form-group">
                         <label>Subtasks</label>
                         <div id="subtasks-container">
                             <div class="subtask-input-group">
                                 <input type="text" id="new-subtask-text" placeholder="Add a subtask and press Enter...">
                                 <button type="button" id="add-subtask-btn-modal" class="btn-icon" title="Add subtask"><i class="fas fa-plus"></i></button>
                             </div>
                             <ul id="subtasks-modal-list">
                                 </ul>
                         </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="secondary" onclick="closeModal(document.getElementById('task-modal'))">Cancel</button>
                    <button type="submit" id="save-task-btn" title="Save task (Ctrl+Alt+S)">Save Task</button>
                </div>
            </form>
        </div>
    </div>

    <div id="confirm-modal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
             <div class="modal-header">
                <h2 id="confirm-modal-title">Confirm Action</h2>
                <button class="close-btn" onclick="closeModal(document.getElementById('confirm-modal'))" aria-label="Close confirmation">&times;</button>
            </div>
            <div class="modal-body">
                <p id="confirm-modal-message">Are you sure?</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="secondary" id="confirm-modal-cancel-btn">Cancel</button>
                <button type="button" id="confirm-modal-confirm-btn">Confirm</button>
            </div>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/relativeTime.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isBetween.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isSameOrAfter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isSameOrBefore.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/isoWeek.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script> <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script> <script>
        // Extend dayjs
        dayjs.extend(dayjs_plugin_relativeTime);
        dayjs.extend(dayjs_plugin_isBetween);
        dayjs.extend(dayjs_plugin_isSameOrAfter);
        dayjs.extend(dayjs_plugin_isSameOrBefore);
        dayjs.extend(dayjs_plugin_isoWeek);
        dayjs.extend(dayjs_plugin_utc); // Add UTC plugin
        dayjs.extend(dayjs_plugin_timezone); // Add Timezone plugin

        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const body = document.body;
            const mainContent = document.querySelector('.main-content');
            const mainTitle = document.getElementById('main-title'); // For changing title based on view
            const addTaskBtn = document.getElementById('add-task-btn');
            const taskModal = document.getElementById('task-modal');
            const confirmModal = document.getElementById('confirm-modal');
            const taskForm = document.getElementById('task-form');
            const modalTitle = document.getElementById('modal-title');
            const taskIdInput = document.getElementById('task-id');
            const taskTitleInput = document.getElementById('task-title');
            const taskDescriptionInput = document.getElementById('task-description');
            const taskPriorityInput = document.getElementById('task-priority');
            const taskDueDateInput = document.getElementById('task-due-date');
            const taskCategoryInput = document.getElementById('task-category');
            const taskRecurrenceInput = document.getElementById('task-recurrence');
            const taskListUl = document.getElementById('task-list');
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const exportTasksBtn = document.getElementById('export-tasks-btn');
            const importTasksInput = document.getElementById('import-tasks-input');
            const filterBtns = document.querySelectorAll('.filter-btn');
            const listViewBtn = document.getElementById('list-view-btn');
            const graphViewBtn = document.getElementById('graph-view-btn');
            const navDashboardLink = document.getElementById('nav-dashboard'); // Sidebar links
            const navGraphLink = document.getElementById('nav-graph');
            const navSettingsLink = document.getElementById('nav-settings');
            const listViewDiv = document.getElementById('list-view');
            const graphViewDiv = document.getElementById('graph-view');
            const taskChartCanvas = document.getElementById('task-chart');
            const notificationBtn = document.getElementById('notification-btn');
            const notificationBtnWrapper = notificationBtn.closest('.notification-btn-wrapper'); // Get wrapper
            const notificationList = document.getElementById('notification-list');
            const notificationBadge = document.getElementById('notification-badge');
            const refreshBtn = document.getElementById('refresh-btn'); // Changed ID from refresh-logo
            const totalTimerDisplaySpan = document.getElementById('total-timer-display').querySelector('span');
            const totalTimerIcon = document.getElementById('total-timer-display').querySelector('i');
            const logoutBtn = document.getElementById('logout-btn');
            const saveTaskBtn = document.getElementById('save-task-btn');
            const batchActionsBar = document.getElementById('batch-actions-bar');
            const selectedCountSpan = document.getElementById('selected-count');
            const batchDeleteBtn = document.getElementById('batch-delete-btn');
            const batchCompleteBtn = document.getElementById('batch-complete-btn');
            const batchUncompleteBtn = document.getElementById('batch-uncomplete-btn');

            // Modal Subtasks
            const subtasksContainer = document.getElementById('subtasks-container');
            const newSubtaskTextInput = document.getElementById('new-subtask-text');
            const addSubtaskBtnModal = document.getElementById('add-subtask-btn-modal');
            const subtasksModalListUl = document.getElementById('subtasks-modal-list');
            let currentModalSubtasks = [];

            // --- State Variables ---
            let todos = [];
            let currentFilter = 'overall';
            let currentView = 'list'; // 'list' or 'graph'
            let editTaskId = null;
            let taskChart = null; // Chart.js instance
            let notifications = []; // { message, type, timestamp, id }
            let timers = {}; // Store timer intervals: { taskId: intervalId }
            let totalTimeToday = 0; // In seconds
            let lastDateCheckedForReset = dayjs.utc().format('YYYY-MM-DD'); // Store GMT date string
            let selectedTaskIds = new Set();
            let notificationCheckInterval;

            // --- Initialization ---
            loadTheme();
            loadTodos(); // Loads tasks and timers
            initializeDatepicker();
            setActiveFilter(currentFilter); // Apply initial filter
            switchView(currentView); // Set initial view
            renderAll(); // Initial full render
            startTotalTimerInterval(); // Start the total timer display interval
            startNotificationChecks(); // Start periodic checks for due dates
            requestNotificationPermission(); // Ask for permission early if not granted/denied

            // --- PWA Service Worker Registration ---
             if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js') // Assumes sw.js is in the root
                    .then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                    console.log('ServiceWorker registration failed: ', error);
                    });
                });
            }

            // --- LocalStorage Functions ---
            function saveTodos() {
                try {
                    // Prune finished timers before saving
                    const todosToSave = todos.map(todo => {
                        // Ensure timer properties exist even if timer never ran
                        return {
                            ...todo,
                            isTimerRunning: todo.isTimerRunning || false,
                            startTime: todo.startTime || null,
                            accumulatedTime: todo.accumulatedTime || 0
                        };
                    });
                    localStorage.setItem('todos', JSON.stringify(todosToSave));
                    // Save total time and reset date separately
                    localStorage.setItem('totalTimeToday', totalTimeToday.toString());
                    localStorage.setItem('lastDateCheckedForReset', lastDateCheckedForReset); // Save GMT date string
                } catch (e) {
                    console.error("Error saving to localStorage:", e);
                    addNotification("Could not save tasks. Storage might be full.", "error");
                }
            }

            function loadTodos() {
                try {
                    const storedTodos = localStorage.getItem('todos');
                    const storedTotalTime = localStorage.getItem('totalTimeToday');
                    const storedLastDate = localStorage.getItem('lastDateCheckedForReset'); // GMT date string

                    if (storedTodos) {
                        todos = JSON.parse(storedTodos);
                        // Ensure all necessary fields exist (backward compatibility & robustness)
                        todos.forEach(todo => {
                            todo.id = todo.id || `task-${Date.now()}-${Math.random()}`; // Ensure ID exists
                            todo.title = todo.title || 'Untitled Task';
                            todo.subtasks = todo.subtasks || [];
                            todo.category = todo.category || 'Uncategorized';
                            todo.recurrence = todo.recurrence || 'none';
                            todo.priority = todo.priority || 'Medium';
                            todo.completed = todo.completed || false;
                            todo.accumulatedTime = Number(todo.accumulatedTime) || 0;
                            todo.isTimerRunning = todo.isTimerRunning || false;
                            todo.startTime = todo.startTime || null; // Should be ISO string if running

                             // Ensure subtasks have IDs
                            if (todo.subtasks) {
                                todo.subtasks.forEach(sub => {
                                    sub.id = sub.id || `sub-${Date.now()}-${Math.random()}`;
                                    sub.completed = sub.completed || false;
                                });
                             }

                            // Recalculate time if timer was running during refresh/close
                            if (todo.isTimerRunning && todo.startTime) {
                                const startTimeMoment = dayjs(todo.startTime);
                                if (startTimeMoment.isValid()) {
                                     const timePassed = dayjs().diff(startTimeMoment, 'second');
                                     if (timePassed > 0) {
                                         todo.accumulatedTime += timePassed;
                                     }
                                     todo.startTime = dayjs().toISOString(); // Reset start time to now for interval
                                     startTimerInterval(todo.id); // Restart interval
                                } else {
                                     // Invalid start time stored, reset timer state
                                     console.warn(`Invalid startTime found for task ${todo.id}. Resetting timer state.`);
                                     todo.isTimerRunning = false;
                                     todo.startTime = null;
                                }
                             } else {
                                 todo.isTimerRunning = false;
                                 todo.startTime = null;
                             }
                        });
                    } else {
                        // Add Sample Tasks if localStorage is empty
                        todos = getSampleTasks();
                    }

                    // Load Total Timer State
                    const todayGMTStr = dayjs.utc().format('YYYY-MM-DD');
                    if (storedLastDate === todayGMTStr && storedTotalTime) {
                        totalTimeToday = parseInt(storedTotalTime, 10) || 0;
                    } else {
                        // Reset if it's a new day or no stored data
                        totalTimeToday = 0;
                        console.log("New day (GMT) detected or no saved total time. Resetting total timer.");
                    }
                    lastDateCheckedForReset = todayGMTStr; // Set initial GMT date

                } catch (e) {
                    console.error("Error loading from localStorage:", e);
                    addNotification("Could not load tasks. Using default samples.", "error");
                    todos = getSampleTasks(); // Fallback to sample data
                    totalTimeToday = 0;
                    lastDateCheckedForReset = dayjs.utc().format('YYYY-MM-DD');
                }
                // Don't render here, happens in Initialization
            }

             function getSampleTasks() {
                 const now = dayjs();
                 const today = now.toISOString();
                 const tomorrow = now.add(1, 'day').toISOString();
                 const nextWeek = now.add(7, 'day').toISOString();
                 const yesterday = now.subtract(1, 'day').toISOString();

                 return [
                     { id: `task-${Date.now() + 1}`, title: "Review project proposal (High Priority)", description: "Go through the latest draft and provide feedback by EOD.", priority: "High", dueDate: tomorrow, completed: false, category: "Work", recurrence: 'none', subtasks: [], accumulatedTime: 0, isTimerRunning: false, startTime: null },
                     { id: `task-${Date.now() + 2}`, title: "Schedule team meeting", description: "Find a suitable time for the weekly sync.", priority: "Medium", dueDate: today, completed: false, category: "Work", recurrence: 'none', subtasks: [{id: `sub-${Date.now()+1}`, text: 'Check calendars', completed: false}, {id: `sub-${Date.now()+2}`, text: 'Send invite', completed: false}], accumulatedTime: 3665, isTimerRunning: false, startTime: null }, // 1h 1m 5s
                     { id: `task-${Date.now() + 3}`, title: "Grocery Shopping (Weekly)", description: "Buy milk, eggs, bread.", priority: "Low", dueDate: today, completed: false, category: "Personal", recurrence: 'weekly', subtasks: [], accumulatedTime: 0, isTimerRunning: false, startTime: null },
                     { id: `task-${Date.now() + 4}`, title: "Pay electricity bill (Overdue)", description: "Due yesterday!", priority: "High", dueDate: yesterday, completed: false, category: "Bills", recurrence: 'monthly', subtasks: [], accumulatedTime: 120, isTimerRunning: false, startTime: null }, // 2 mins
                     { id: `task-${Date.now() + 5}`, title: "Read Ch. 5 JS book (Completed)", description: "", priority: "Medium", dueDate: nextWeek, completed: true, category: "Study", recurrence: 'none', subtasks: [], accumulatedTime: 7200, isTimerRunning: false, startTime: null }, // 2 hours
                     { id: `task-${Date.now() + 6}`, title: "Submit expense report", description: "Deadline is end of week", priority: "High", dueDate: now.endOf('isoWeek').toISOString(), completed: false, category: "Work", recurrence: 'none', subtasks: [], accumulatedTime: 0, isTimerRunning: false, startTime: null },
                 ];
             }

            // --- Theme Management ---
            function loadTheme() {
                const isDarkMode = localStorage.getItem('darkMode') === 'true';
                if (isDarkMode) {
                    body.classList.add('dark-mode');
                    themeToggleBtn.querySelector('i').classList.replace('fa-moon', 'fa-sun');
                    themeToggleBtn.querySelector('span').textContent = 'Light Mode';
                    themeToggleBtn.title = 'Switch to light mode';
                } else {
                    body.classList.remove('dark-mode');
                    themeToggleBtn.querySelector('i').classList.replace('fa-sun', 'fa-moon');
                     themeToggleBtn.querySelector('span').textContent = 'Dark Mode';
                     themeToggleBtn.title = 'Switch to dark mode';
                }
                // Update chart colors if chart exists
                 if (taskChart) updateChartConfig();
            }

            function toggleTheme() {
                body.classList.toggle('dark-mode');
                const isDarkMode = body.classList.contains('dark-mode');
                localStorage.setItem('darkMode', isDarkMode);
                loadTheme(); // Update button text/icon and chart
            }

            // --- Modal Handling ---
            function openModal(modalElement) {
                 modalElement.style.display = 'flex';
                 setTimeout(() => {
                    modalElement.classList.add('visible');
                    if (modalElement === taskModal) {
                       taskTitleInput.focus(); // Focus first field in task modal
                    }
                 }, 10); // For potential transition
            }

            function closeModal(modalElement) {
                 modalElement.classList.remove('visible');
                 // Use setTimeout to allow animation to finish before hiding
                 setTimeout(() => {
                    modalElement.style.display = 'none';
                    // Reset task modal form
                    if (modalElement === taskModal) {
                        taskForm.reset();
                        taskIdInput.value = '';
                        editTaskId = null;
                        modalTitle.textContent = 'Add Task';
                        saveTaskBtn.textContent = 'Save Task';
                        initializeDatepicker(); // Re-init datepicker after reset
                        // Clear modal subtasks
                        currentModalSubtasks = [];
                        renderModalSubtasks();
                        taskPriorityInput.value = 'Medium'; // Reset priority to default
                        taskRecurrenceInput.value = 'none'; // Reset recurrence
                    }
                     // Reset confirm modal buttons
                     if (modalElement === confirmModal) {
                        const confirmBtn = document.getElementById('confirm-modal-confirm-btn');
                        const cancelBtn = document.getElementById('confirm-modal-cancel-btn');
                        confirmBtn.onclick = null; // Remove previous listener
                        cancelBtn.onclick = () => closeModal(confirmModal); // Default cancel action
                    }
                 }, 300); // Match modal animation duration if any
            }

            function openConfirmModal(message, onConfirm) {
                document.getElementById('confirm-modal-message').textContent = message;
                const confirmBtn = document.getElementById('confirm-modal-confirm-btn');
                const cancelBtn = document.getElementById('confirm-modal-cancel-btn'); // Get cancel button

                confirmBtn.onclick = () => {
                    onConfirm();
                    closeModal(confirmModal);
                };
                 // Ensure cancel button also closes the modal
                cancelBtn.onclick = () => closeModal(confirmModal);

                openModal(confirmModal);
            }

            // --- Datepicker ---
            let dueDatePicker;
            function initializeDatepicker() {
                 if (dueDatePicker) dueDatePicker.destroy(); // Destroy previous instance if exists
                 dueDatePicker = flatpickr("#task-due-date", {
                    enableTime: true,
                    dateFormat: "Y-m-d H:i", // Internal format for saving
                    altInput: true, // Human-readable format in the input field
                    altFormat: "M j, Y h:i K", // e.g., Apr 16, 2025 10:30 AM
                    time_24hr: false,
                    minuteIncrement: 1, // Allow selecting any minute
                 });
            }

            // --- Task CRUD ---
            function addTask(taskData) {
                const newTask = {
                    id: `task-${Date.now()}`,
                    completed: false,
                    accumulatedTime: 0,
                    isTimerRunning: false,
                    startTime: null,
                    subtasks: taskData.subtasks || [], // Use subtasks from modal
                    ...taskData
                };
                todos.unshift(newTask); // Add to the beginning of the array
                addNotification(`Task "${newTask.title}" added.`, 'success');
                saveTodos();
                renderAll();
            }

            function updateTask(id, updatedData) {
                 let taskUpdated = false;
                 let originalTitle = '';
                 todos = todos.map(todo => {
                     if (todo.id === id) {
                         taskUpdated = true;
                         originalTitle = todo.title;
                         // Merge updated data carefully, ensuring subtasks are handled
                         const newSubtasks = updatedData.subtasks || [];
                         const existingSubtasks = todo.subtasks || [];
                         // Preserve completion status of existing subtasks if they still exist
                         const mergedSubtasks = newSubtasks.map(newSub => {
                             const existingSub = existingSubtasks.find(oldSub => oldSub.id === newSub.id);
                             return existingSub ? { ...newSub, completed: existingSub.completed } : newSub;
                         });
                         return { ...todo, ...updatedData, subtasks: mergedSubtasks };
                     }
                     return todo;
                 });
                 if(taskUpdated) {
                     addNotification(`Task "${updatedData.title || originalTitle}" updated.`, 'info');
                     saveTodos();
                     renderAll();
                 } else {
                     console.error("Update failed: Task ID not found", id);
                 }
            }

            function deleteTask(id) {
                 const taskIndex = todos.findIndex(todo => todo.id === id);
                 if (taskIndex === -1) return;

                 const taskToDelete = todos[taskIndex];
                 stopTimer(id); // Stop timer if running before deleting
                 delete timers[id]; // Remove timer interval ref

                 todos.splice(taskIndex, 1); // Remove task from array
                 selectedTaskIds.delete(id); // Remove from selection if present
                 addNotification(`Task "${taskToDelete.title}" deleted.`, 'success');
                 saveTodos();
                 renderAll();
            }

            function toggleComplete(id) {
                let taskCompleted = null;
                let nextDueDate = null;
                let recurrenceHandled = false;

                todos = todos.map(todo => {
                    if (todo.id === id) {
                        const newCompletedState = !todo.completed;
                        taskCompleted = { ...todo, completed: newCompletedState }; // Store the task for notification/recurrence

                        if (newCompletedState && todo.isTimerRunning) {
                            pauseTimer(id); // Pause timer when marking complete
                        }

                        // Handle Recurrence ONLY IF MARKING AS COMPLETE
                        if (newCompletedState && todo.recurrence && todo.recurrence !== 'none' && todo.dueDate) {
                            nextDueDate = calculateNextDueDate(todo.dueDate, todo.recurrence);
                            addNotification(`Recurring task "${todo.title}" completed. Next due date set for ${dayjs(nextDueDate).format('MMM D, YYYY')}.`, 'info');
                             // Modify the current task to become the next instance
                            recurrenceHandled = true;
                            return { ...taskCompleted, completed: false, dueDate: nextDueDate }; // Reset completion, update due date
                        }

                        return taskCompleted; // Return the updated task (completion toggled)
                    }
                    return todo;
                });

                 if (taskCompleted && !recurrenceHandled) { // Don't double-notify if recurrence handled it
                    addNotification(`Task "${taskCompleted.title}" marked as ${taskCompleted.completed ? 'complete' : 'incomplete'}.`, 'info');
                 }
                 selectedTaskIds.delete(id); // Remove from selection after action
                saveTodos();
                renderAll();
            }

             // --- Batch Actions ---
             function updateBatchActionUI() {
                 const count = selectedTaskIds.size;
                 if (count > 0) {
                     selectedCountSpan.textContent = `${count} selected`;
                     batchActionsBar.classList.add('visible');
                 } else {
                     batchActionsBar.classList.remove('visible');
                 }
             }

             function handleTaskSelectionChange(taskId, isSelected) {
                 const checkbox = taskListUl.querySelector(`.task-item[data-id="${taskId}"] .task-select-checkbox`);
                 if (isSelected) {
                     selectedTaskIds.add(taskId);
                     if(checkbox) checkbox.checked = true; // Ensure visual sync
                 } else {
                     selectedTaskIds.delete(taskId);
                     if(checkbox) checkbox.checked = false; // Ensure visual sync
                 }
                 updateBatchActionUI();
             }

              function clearSelection() {
                selectedTaskIds.forEach(id => {
                    const checkbox = taskListUl.querySelector(`.task-item[data-id="${id}"] .task-select-checkbox`);
                    if (checkbox) checkbox.checked = false;
                });
                selectedTaskIds.clear();
                updateBatchActionUI();
             }

             function batchDelete() {
                 const count = selectedTaskIds.size;
                 if (count === 0) return;
                 openConfirmModal(`Are you sure you want to delete ${count} selected task(s)?`, () => {
                    let deletedCount = 0;
                    // Iterate over a copy because we modify the set during iteration
                    const idsToDelete = new Set(selectedTaskIds);
                    idsToDelete.forEach(id => {
                        deleteTask(id); // Use existing deleteTask function
                        deletedCount++;
                    });
                    // deleteTask already calls saveTodos and renderAll, but clear selection here
                    clearSelection();
                     // Add a single summary notification
                    if (deletedCount > 0) {
                        // Notifications are already added by deleteTask, maybe suppress them there?
                        // For now, let individual notifications stand.
                    }
                 });
             }

             function batchToggleComplete(markAsComplete) {
                 const count = selectedTaskIds.size;
                 if (count === 0) return;
                 let updatedCount = 0;
                 let actionText = markAsComplete ? 'complete' : 'incomplete';
                 let recurrenceWarning = false;

                 todos = todos.map(todo => {
                    if (selectedTaskIds.has(todo.id)) {
                        if (todo.completed !== markAsComplete) {
                             updatedCount++;
                             let updatedTodo = { ...todo, completed: markAsComplete };
                             if (markAsComplete && updatedTodo.isTimerRunning) {
                                pauseTimer(todo.id); // Pause timer when marking complete
                             }
                             // Handle recurrence if marking complete
                             if (markAsComplete && todo.recurrence && todo.recurrence !== 'none' && todo.dueDate) {
                                 updatedTodo.dueDate = calculateNextDueDate(todo.dueDate, todo.recurrence);
                                 updatedTodo.completed = false; // Reset for next occurrence
                                 recurrenceWarning = true; // Indicate recurrence was handled
                             }
                             return updatedTodo;
                        }
                    }
                    return todo;
                 });

                 if (updatedCount > 0) {
                     let message = `${updatedCount} task(s) marked as ${actionText}.`;
                     if (recurrenceWarning) {
                         message += " Next due dates set for recurring tasks.";
                     }
                     addNotification(message, 'info');
                 }
                 // Save and re-render after the loop
                 saveTodos();
                 renderAll();
                 clearSelection();
             }


            // --- Subtask Handling ---
            function toggleSubtask(taskId, subtaskId) {
                 let parentTaskTitle = '';
                 let subtaskText = '';
                 let subtaskCompleted = false;

                 todos = todos.map(todo => {
                     if (todo.id === taskId) {
                         parentTaskTitle = todo.title;
                         const updatedSubtasks = todo.subtasks.map(sub => {
                             if (sub.id === subtaskId) {
                                 subtaskText = sub.text;
                                 subtaskCompleted = !sub.completed;
                                 return { ...sub, completed: subtaskCompleted };
                             }
                             return sub;
                         });
                         // Optional: Check if parent should be marked complete (can be annoying)
                         // const allSubtasksComplete = updatedSubtasks.every(sub => sub.completed);
                         // const parentCompleted = allSubtasksComplete ? true : todo.completed;
                         return { ...todo, subtasks: updatedSubtasks };
                     }
                     return todo;
                 });

                 if (parentTaskTitle && subtaskText) {
                    // Optionally add a notification
                    // addNotification(`Subtask "${subtaskText}" in "${parentTaskTitle}" marked as ${subtaskCompleted ? 'complete' : 'incomplete'}.`, 'info');
                 }
                 saveTodos();
                 renderAll(); // Re-render to show updated subtask state
            }

            // Modal Subtask Functions
            function renderModalSubtasks() {
                subtasksModalListUl.innerHTML = '';
                if (currentModalSubtasks.length === 0) {
                    subtasksModalListUl.innerHTML = '<li style="color: var(--muted-text); font-style: italic; text-align: center;">No subtasks added yet.</li>';
                     return;
                }
                currentModalSubtasks.forEach(sub => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>${escapeHtml(sub.text)}</span>
                        <button type="button" data-subid="${sub.id}" class="delete-subtask-btn-modal" title="Remove subtask"><i class="fas fa-times"></i></button>
                    `;
                    subtasksModalListUl.appendChild(li);

                     // Add event listener for delete button in modal
                    li.querySelector('.delete-subtask-btn-modal').addEventListener('click', (e) => {
                         e.preventDefault(); // Prevent form submission
                         const subIdToDelete = e.currentTarget.getAttribute('data-subid');
                         currentModalSubtasks = currentModalSubtasks.filter(s => s.id !== subIdToDelete);
                         renderModalSubtasks(); // Re-render the list in the modal
                    });
                });
            }

             function addSubtaskToModal() {
                const text = newSubtaskTextInput.value.trim();
                if (text) {
                     // Ensure unique ID even if added quickly
                    currentModalSubtasks.push({ id: `sub-${Date.now()}-${Math.random().toString(16).slice(2)}`, text: text, completed: false });
                    newSubtaskTextInput.value = '';
                    renderModalSubtasks();
                    newSubtaskTextInput.focus();
                 }
            }


            // --- Recurrence ---
            function calculateNextDueDate(currentDueDate, recurrence) {
                 const date = dayjs(currentDueDate);
                 if (!date.isValid()) return currentDueDate; // Return original if invalid

                 switch (recurrence) {
                     case 'daily': return date.add(1, 'day').toISOString();
                     case 'weekly': return date.add(1, 'week').toISOString();
                     case 'monthly': return date.add(1, 'month').toISOString();
                     default: return currentDueDate; // Should not happen if called correctly
                 }
            }

            // --- Timer Functions ---
             function formatTime(totalSeconds) {
                 const hours = Math.floor(totalSeconds / 3600);
                 const minutes = Math.floor((totalSeconds % 3600) / 60);
                 const seconds = totalSeconds % 60;
                 return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
             }

             function startTimer(id) {
                const taskIndex = todos.findIndex(todo => todo.id === id);
                if (taskIndex === -1 || todos[taskIndex].isTimerRunning) return;

                // Mark as running and set start time
                 todos[taskIndex].isTimerRunning = true;
                 todos[taskIndex].startTime = dayjs().toISOString(); // Record start time

                 // Start the interval timer
                 startTimerInterval(id);
                 addNotification(`Timer started for "${todos[taskIndex].title}".`, 'info');

                 // Save the running state and start time immediately
                 saveTodos();

                 // Update the specific task item's UI
                 const taskItem = taskListUl.querySelector(`.task-item[data-id="${id}"]`);
                 if(taskItem) updateTaskItemUI(taskItem, todos[taskIndex]);

                 updateTotalTimerDisplay(); // Update total display
             }

             function startTimerInterval(id) {
                 // Clear existing interval for this task ID if it exists
                 if (timers[id]) clearInterval(timers[id]);

                 timers[id] = setInterval(() => {
                     const taskIndex = todos.findIndex(todo => todo.id === id);
                     // Stop interval if task not found or explicitly stopped
                     if (taskIndex === -1 || !todos[taskIndex].isTimerRunning) {
                         clearInterval(timers[id]);
                         delete timers[id];
                         updateTotalTimerDisplay(); // Update total in case this was the last timer
                         return;
                     }

                     // Increment accumulated time for the task and the total time
                     todos[taskIndex].accumulatedTime += 1;
                     totalTimeToday += 1;

                    // Update UI for the specific task timer display
                    const timerDisplay = document.querySelector(`.task-item[data-id="${id}"] .task-timer-display`);
                     if (timerDisplay) {
                         timerDisplay.textContent = formatTime(todos[taskIndex].accumulatedTime);
                     }
                     // Global timer UI is updated by its own interval `startTotalTimerInterval`
                     // updateTotalTimerDisplay(); // This would be too frequent here

                     // Optionally save periodically (e.g., every 30 seconds) to prevent data loss on crash
                     // if (todos[taskIndex].accumulatedTime % 30 === 0) {
                     //     saveTodos();
                     // }

                 }, 1000);
             }

             function pauseTimer(id) {
                 const taskIndex = todos.findIndex(todo => todo.id === id);
                 if (taskIndex === -1 || !todos[taskIndex].isTimerRunning) return;

                  // Clear the interval
                 clearInterval(timers[id]);
                 delete timers[id];

                 // Calculate time elapsed since last start time and add to accumulated
                 const startTimeMoment = dayjs(todos[taskIndex].startTime);
                 if(startTimeMoment.isValid()) {
                    const timePassed = dayjs().diff(startTimeMoment, 'second');
                    if (timePassed > 0) {
                         todos[taskIndex].accumulatedTime += timePassed;
                    }
                 } else {
                    console.warn(`Invalid startTime found for task ${id} during pause. Accumulated time might be inaccurate.`);
                 }

                 // Update task state
                 todos[taskIndex].isTimerRunning = false;
                 todos[taskIndex].startTime = null;

                addNotification(`Timer paused for "${todos[taskIndex].title}".`, 'info');

                 // Save the paused state and final accumulated time
                 saveTodos();

                 // Update the specific task item's UI
                 const taskItem = taskListUl.querySelector(`.task-item[data-id="${id}"]`);
                 if(taskItem) updateTaskItemUI(taskItem, todos[taskIndex]);

                 updateTotalTimerDisplay(); // Update total display in case this was the last timer
             }

             function stopTimer(id) {
                 // Similar to pause, but used when the timer should definitely stop (e.g., task deletion)
                 const taskIndex = todos.findIndex(todo => todo.id === id);

                 // Clear interval if it exists
                 if (timers[id]) {
                     clearInterval(timers[id]);
                     delete timers[id];
                 }

                 // Update task state if found
                 if (taskIndex !== -1) {
                      if (todos[taskIndex].isTimerRunning) {
                         // If it was running, calculate final elapsed time
                         const startTimeMoment = dayjs(todos[taskIndex].startTime);
                         if(startTimeMoment.isValid()) {
                            const timePassed = dayjs().diff(startTimeMoment, 'second');
                            if (timePassed > 0) {
                                todos[taskIndex].accumulatedTime += timePassed;
                                // Do NOT add to totalTimeToday here, as it might be double counted if pause was called first
                                // Or if stop is called before the interval increments it. Let the interval handle totalTimeToday.
                            }
                         }
                         todos[taskIndex].isTimerRunning = false;
                         todos[taskIndex].startTime = null;
                      }
                      // Update UI for the stopped timer
                      const taskItem = taskListUl.querySelector(`.task-item[data-id="${id}"]`);
                      if (taskItem) updateTaskItemUI(taskItem, todos[taskIndex]);
                 }
                  // Note: Don't save here, let the calling function (delete, batch actions, etc.) handle saving.
                  updateTotalTimerDisplay(); // Update total display
             }

             function stopAllTimers() {
                 console.log("Stopping all running timers...");
                 Object.keys(timers).forEach(id => {
                     // Use pause to correctly calculate accumulated time before clearing
                     pauseTimer(id);
                 });
                 // Ensure state is saved after pausing all
                 saveTodos();
                 console.log("All timers paused/stopped and state saved.");
             }

             // Total Timer Logic
            let totalTimerIntervalId = null;
             function startTotalTimerInterval() {
                if (totalTimerIntervalId) clearInterval(totalTimerIntervalId);
                 updateTotalTimerDisplay(); // Initial display

                 totalTimerIntervalId = setInterval(() => {
                     // Check for day change based on GMT
                    const nowGMT = dayjs.utc();
                    const todayGMTStr = nowGMT.format('YYYY-MM-DD');

                     // Check if the GMT date string has changed
                    if (todayGMTStr !== lastDateCheckedForReset) {
                        console.log(`Midnight GMT passed (${todayGMTStr}). Resetting total timer from ${formatTime(totalTimeToday)}.`);
                        totalTimeToday = 0; // Reset counter
                        lastDateCheckedForReset = todayGMTStr; // Update last check date (GMT string)
                        // Save reset state immediately
                        localStorage.setItem('totalTimeToday', '0');
                        localStorage.setItem('lastDateCheckedForReset', lastDateCheckedForReset);
                         addNotification("Daily total timer reset (00:00 GMT).", "info");
                     }

                     // Update display every second regardless of reset
                     updateTotalTimerDisplay();

                 }, 1000); // Check every second
             }

             function updateTotalTimerDisplay() {
                 if (totalTimerDisplaySpan) {
                    totalTimerDisplaySpan.textContent = `Total Today: ${formatTime(totalTimeToday)}`;
                 }
                 // Optional: Make icon pulse if any timer is active
                 const anyTimerActive = Object.keys(timers).length > 0;
                 if (totalTimerIcon) {
                    if (anyTimerActive) {
                        totalTimerIcon.style.color = 'var(--lm-priority-high)'; // Or use CSS animation
                        totalTimerIcon.classList.add('fa-beat'); // Add FontAwesome beat animation
                    } else {
                        totalTimerIcon.style.color = 'inherit'; // Reset color
                        totalTimerIcon.classList.remove('fa-beat'); // Remove animation
                    }
                 }
             }

            // --- Rendering Functions ---
            function renderAll() {
                 console.log("Rendering all..."); // Debug log
                 renderTaskList();
                 renderNotifications();
                 updateChart(); // Update chart data if visible
                 updateBatchActionUI(); // Ensure batch bar is correct
                 updateTotalTimerDisplay(); // Update total timer
                 updateActiveNav(); // Update sidebar navigation highlight
            }

             function renderTaskList() {
                taskListUl.innerHTML = ''; // Clear existing list
                const filteredTodos = filterTodos(todos, currentFilter);

                 if (filteredTodos.length === 0) {
                    taskListUl.innerHTML = '<li style="text-align: center; color: var(--muted-text); padding: 2rem;">No tasks match the current filter.</li>';
                    return;
                 }

                // Sort tasks: Incomplete first, then by due date (earliest first, nulls last), then by priority (High first)
                filteredTodos.sort((a, b) => {
                    // 1. Completion Status (Incomplete first)
                    if (a.completed !== b.completed) return a.completed ? 1 : -1;

                    // 2. Due Date (Earliest first, nulls/invalid last)
                    const dateA = a.dueDate ? dayjs(a.dueDate) : null;
                    const dateB = b.dueDate ? dayjs(b.dueDate) : null;
                    const dateAValid = dateA?.isValid();
                    const dateBValid = dateB?.isValid();

                    if (dateAValid && dateBValid) {
                        if (dateA.isBefore(dateB)) return -1;
                        if (dateA.isAfter(dateB)) return 1;
                    } else if (dateAValid) {
                        return -1; // dateA is valid, dateB is not -> A comes first
                    } else if (dateBValid) {
                        return 1;  // dateB is valid, dateA is not -> B comes first
                    }
                    // If dates are same or both invalid, continue to priority

                    // 3. Priority (High > Medium > Low)
                    const priorityOrder = { High: 1, Medium: 2, Low: 3 };
                    const priorityA = priorityOrder[a.priority] || 3;
                    const priorityB = priorityOrder[b.priority] || 3;
                    if (priorityA !== priorityB) return priorityA - priorityB;

                    // 4. Creation Time (Implicitly by ID - newer tasks might appear slightly higher if IDs are sequential timestamps)
                    // Or add a creationTimestamp property if strict creation order is needed.
                    return 0; // Keep original order if all else is equal
                });

                filteredTodos.forEach(todo => {
                    const taskItem = createTaskItemElement(todo); // Use function to create element
                    if(taskItem) taskListUl.appendChild(taskItem);
                });
             }

             // Creates the DOM element for a single task
             function createTaskItemElement(todo) {
                 if (!todo || !todo.id) {
                     console.error("Attempted to render invalid todo:", todo);
                     return null; // Skip rendering invalid data
                 }

                 const taskItem = document.createElement('li');
                 taskItem.classList.add('task-item');
                 taskItem.dataset.id = todo.id; // Set ID for easy selection

                 // Add classes based on state
                 taskItem.classList.toggle('completed', todo.completed);
                 taskItem.classList.add(`priority-${todo.priority}`);
                 const isOverdue = todo.dueDate && dayjs(todo.dueDate).isBefore(dayjs(), 'day') && !todo.completed;
                 taskItem.classList.toggle('overdue', isOverdue);

                 // Calculate completion percentage for subtasks
                 const subtaskCount = todo.subtasks?.length || 0;
                 const completedSubtaskCount = todo.subtasks?.filter(s => s.completed).length || 0;
                 const subtaskProgressText = subtaskCount > 0 ? `(${completedSubtaskCount}/${subtaskCount})` : '';

                // --- Inner HTML Structure ---
                taskItem.innerHTML = `
                    <div class="task-selection">
                        <input type="checkbox" class="task-select-checkbox" aria-label="Select task ${escapeHtml(todo.title)}" ${selectedTaskIds.has(todo.id) ? 'checked' : ''} title="Select task for batch actions">
                    </div>
                    <div class="task-details">
                        <h3>${escapeHtml(todo.title)}</h3>
                        <div class="task-info">
                            <span class="priority" title="Priority: ${todo.priority}"><span class="priority-tag ${escapeHtml(todo.priority)}">${escapeHtml(todo.priority)}</span></span>
                            ${todo.category ? `<span title="Category: ${escapeHtml(todo.category)}"><i class="fas fa-folder"></i> ${escapeHtml(todo.category)}</span>` : ''}
                            ${todo.dueDate ? `<span title="Due: ${dayjs(todo.dueDate).format('llll')}"><i class="fas fa-calendar-alt"></i> ${dayjs(todo.dueDate).fromNow()}</span>` : '<span title="No due date"><i class="fas fa-calendar-times"></i> No due date</span>'}
                            ${todo.recurrence && todo.recurrence !== 'none' ? `<span title="Recurring ${todo.recurrence}"><i class="fas fa-redo"></i> ${escapeHtml(todo.recurrence.charAt(0).toUpperCase() + todo.recurrence.slice(1))}</span>` : ''}
                         </div>
                        ${todo.description ? `<p class="task-description">${escapeHtml(todo.description)}</p>` : ''}
                         ${subtaskCount > 0 ? `
                            <div class="subtasks-section">
                                <div class="subtasks-toggle" title="Toggle subtasks visibility">
                                    <i class="fas fa-chevron-right"></i> Subtasks ${subtaskProgressText}
                                </div>
                                <ul class="subtasks-list">
                                    ${renderSubtasksList(todo.id, todo.subtasks)}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                    <div class="task-controls">
                         <button class="complete-btn" title="${todo.completed ? 'Mark as Incomplete' : 'Mark as Complete'}">
                             <i class="fas ${todo.completed ? 'fa-undo' : 'fa-check-circle'}"></i>
                         </button>
                         <button class="edit-btn" title="Edit Task"><i class="fas fa-edit"></i></button>
                         <button class="delete-btn" title="Delete Task"><i class="fas fa-trash-alt"></i></button>
                         <button class="timer-btn ${todo.isTimerRunning ? 'active' : ''}" title="${todo.isTimerRunning ? 'Pause Timer' : 'Start Timer'}">
                             <i class="fas ${todo.isTimerRunning ? 'fa-pause-circle' : 'fa-play-circle'}"></i>
                         </button>
                         <div class="task-timer-display" title="Time tracked for this task">${formatTime(todo.accumulatedTime)}</div>
                    </div>
                `;

                 attachTaskItemListeners(taskItem, todo); // Attach listeners separately
                 return taskItem;
             }

            // Updates the UI of an existing task item element without full re-render
             function updateTaskItemUI(taskItem, todo) {
                 if (!taskItem || !todo) return;

                 // Update classes
                 taskItem.classList.toggle('completed', todo.completed);
                 taskItem.classList.remove('priority-High', 'priority-Medium', 'priority-Low', 'overdue'); // Clear old classes
                 taskItem.classList.add(`priority-${todo.priority}`);
                 const isOverdue = todo.dueDate && dayjs(todo.dueDate).isBefore(dayjs(), 'day') && !todo.completed;
                 taskItem.classList.toggle('overdue', isOverdue);

                 // Update specific elements
                 taskItem.querySelector('.task-details h3').textContent = escapeHtml(todo.title);
                 // Re-render info bar (simpler than updating each part)
                 const infoBar = taskItem.querySelector('.task-info');
                 if (infoBar) {
                     infoBar.innerHTML = `
                        <span class="priority" title="Priority: ${todo.priority}"><span class="priority-tag ${escapeHtml(todo.priority)}">${escapeHtml(todo.priority)}</span></span>
                        ${todo.category ? `<span title="Category: ${escapeHtml(todo.category)}"><i class="fas fa-folder"></i> ${escapeHtml(todo.category)}</span>` : ''}
                        ${todo.dueDate ? `<span title="Due: ${dayjs(todo.dueDate).format('llll')}"><i class="fas fa-calendar-alt"></i> ${dayjs(todo.dueDate).fromNow()}</span>` : '<span title="No due date"><i class="fas fa-calendar-times"></i> No due date</span>'}
                        ${todo.recurrence && todo.recurrence !== 'none' ? `<span title="Recurring ${todo.recurrence}"><i class="fas fa-redo"></i> ${escapeHtml(todo.recurrence.charAt(0).toUpperCase() + todo.recurrence.slice(1))}</span>` : ''}
                    `;
                 }
                const descriptionP = taskItem.querySelector('.task-description');
                if (descriptionP) descriptionP.textContent = escapeHtml(todo.description);

                 // Update timer display and button state
                 const timerDisplay = taskItem.querySelector('.task-timer-display');
                 if(timerDisplay) timerDisplay.textContent = formatTime(todo.accumulatedTime);
                 const timerBtn = taskItem.querySelector('.timer-btn');
                 if(timerBtn) {
                     timerBtn.classList.toggle('active', todo.isTimerRunning);
                     timerBtn.title = todo.isTimerRunning ? 'Pause Timer' : 'Start Timer';
                     timerBtn.querySelector('i').className = `fas ${todo.isTimerRunning ? 'fa-pause-circle' : 'fa-play-circle'}`;
                 }
                 // Update complete button icon/title
                 const completeBtn = taskItem.querySelector('.complete-btn');
                 if(completeBtn) {
                     completeBtn.title = todo.completed ? 'Mark as Incomplete' : 'Mark as Complete';
                     completeBtn.querySelector('i').className = `fas ${todo.completed ? 'fa-undo' : 'fa-check-circle'}`;
                 }

                 // Update checkbox state
                 const checkbox = taskItem.querySelector('.task-select-checkbox');
                 if (checkbox) checkbox.checked = selectedTaskIds.has(todo.id);

                 // Update subtasks (more complex, might need full re-render of subtask section or careful updates)
                 // Simple approach for now: re-render subtask section if needed
                 const subtaskSection = taskItem.querySelector('.subtasks-section');
                  const subtaskCount = todo.subtasks?.length || 0;
                  if (subtaskCount > 0) {
                     if (!subtaskSection) {
                        // Add subtask section if it didn't exist before
                        const detailsDiv = taskItem.querySelector('.task-details');
                        if (detailsDiv) {
                             const newSubtaskSection = document.createElement('div');
                             newSubtaskSection.classList.add('subtasks-section');
                             // Populate innerHTML and attach listeners... (omitted for brevity, ideally call a function)
                             detailsDiv.appendChild(newSubtaskSection);
                        }
                     } else {
                         // Update existing subtask section
                         const completedSubtaskCount = todo.subtasks?.filter(s => s.completed).length || 0;
                         const subtaskProgressText = `(${completedSubtaskCount}/${subtaskCount})`;
                         const toggle = subtaskSection.querySelector('.subtasks-toggle');
                         if(toggle) toggle.innerHTML = `<i class="fas fa-chevron-right ${toggle.classList.contains('open') ? 'open' : ''}"></i> Subtasks ${subtaskProgressText}`;
                         const sublist = subtaskSection.querySelector('.subtasks-list');
                         if(sublist) sublist.innerHTML = renderSubtasksList(todo.id, todo.subtasks);
                         // Re-attach listeners for new/updated subtasks
                         attachSubtaskListeners(taskItem, todo);
                     }
                  } else if (subtaskSection) {
                     // Remove subtask section if no subtasks anymore
                     subtaskSection.remove();
                  }
             }

             // Attaches event listeners to a task item element
             function attachTaskItemListeners(taskItem, todo) {
                const checkbox = taskItem.querySelector('.task-select-checkbox');
                const completeBtn = taskItem.querySelector('.complete-btn');
                const editBtn = taskItem.querySelector('.edit-btn');
                const deleteBtn = taskItem.querySelector('.delete-btn');
                const timerBtn = taskItem.querySelector('.timer-btn');
                const subtasksToggle = taskItem.querySelector('.subtasks-toggle');

                 // Click on task item (excluding controls) to edit
                 taskItem.addEventListener('click', (e) => {
                     if (!e.target.closest('.task-controls') &&
                         !e.target.closest('.task-selection') &&
                         !e.target.closest('.subtasks-section')) {
                         editTask(todo.id);
                     }
                 });

                 checkbox.addEventListener('change', (e) => {
                    handleTaskSelectionChange(todo.id, e.target.checked);
                 });
                 checkbox.addEventListener('click', (e) => e.stopPropagation()); // Prevent task item click trigger

                 completeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent task item click trigger
                    toggleComplete(todo.id);
                 });

                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editTask(todo.id);
                });

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openConfirmModal(`Are you sure you want to delete task "${todo.title}"? This cannot be undone.`, () => {
                         deleteTask(todo.id);
                    });
                });

                timerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (todo.isTimerRunning) {
                        pauseTimer(todo.id);
                    } else {
                         // Prevent starting timer on completed tasks? Optional.
                         // if (todo.completed) {
                         //    addNotification("Cannot start timer on a completed task.", "warning");
                         //    return;
                         // }
                         startTimer(todo.id);
                    }
                });

                if (subtasksToggle) {
                     subtasksToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const icon = subtasksToggle.querySelector('i');
                        const sublist = taskItem.querySelector('.subtasks-list');
                        if (sublist && icon) {
                            sublist.classList.toggle('open');
                            subtasksToggle.classList.toggle('open'); // For styling the toggle itself
                            icon.classList.toggle('fa-chevron-right');
                            icon.classList.toggle('fa-chevron-down'); // More intuitive toggle icon
                         }
                     });
                 }

                 // Attach listeners to subtasks within this item
                 attachSubtaskListeners(taskItem, todo);
             }

             // Attaches listeners for subtasks within a specific task item
             function attachSubtaskListeners(taskItem, todo) {
                const subtaskCheckboxes = taskItem.querySelectorAll('.subtask-item input[type="checkbox"]');
                 subtaskCheckboxes.forEach(subCheckbox => {
                     // Prevent multiple listeners if re-rendering
                     // A simple way: store a flag, or use a more robust event delegation pattern
                     if (!subCheckbox.dataset.listenerAttached) {
                         subCheckbox.addEventListener('click', (e) => e.stopPropagation()); // Prevent item click
                         subCheckbox.addEventListener('change', (e) => {
                             const subtaskId = e.target.dataset.subid;
                             toggleSubtask(todo.id, subtaskId);
                         });
                         subCheckbox.dataset.listenerAttached = 'true';
                     }
                 });
             }

             function renderSubtasksList(taskId, subtasks) {
                 if (!subtasks || subtasks.length === 0) return '';
                 return subtasks.map(sub => `
                    <li class="subtask-item ${sub.completed ? 'completed' : ''}">
                        <input type="checkbox" data-taskid="${taskId}" data-subid="${sub.id}" ${sub.completed ? 'checked' : ''} aria-label="Subtask ${escapeHtml(sub.text)}" title="${sub.completed ? 'Mark subtask incomplete' : 'Mark subtask complete'}">
                        <span>${escapeHtml(sub.text)}</span>
                    </li>
                 `).join('');
             }

            // --- Filtering ---
             function filterTodos(allTodos, filter) {
                const now = dayjs();
                switch (filter) {
                    case 'today':
                        return allTodos.filter(todo => todo.dueDate && dayjs(todo.dueDate).isSame(now, 'day'));
                    case 'week':
                         const startOfWeek = now.startOf('isoWeek'); // Use ISO week (Mon-Sun)
                         const endOfWeek = now.endOf('isoWeek');
                         return allTodos.filter(todo => todo.dueDate && dayjs(todo.dueDate).isBetween(startOfWeek, endOfWeek, 'day', '[]')); // inclusive check on day level
                    case 'month':
                        const startOfMonth = now.startOf('month');
                        const endOfMonth = now.endOf('month');
                        return allTodos.filter(todo => todo.dueDate && dayjs(todo.dueDate).isBetween(startOfMonth, endOfMonth, 'day', '[]')); // inclusive check on day level
                    case 'overall':
                    default:
                        return allTodos; // Return a copy to prevent mutation? No, filter creates a new array.
                }
            }

            function setActiveFilter(filter) {
                currentFilter = filter;
                filterBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.filter === filter);
                });
                clearSelection(); // Clear selection when changing filters
                renderTaskList(); // Re-render list with new filter
            }

            // --- View Switching ---
            function switchView(view) {
                 if (view === currentView) return;

                 currentView = view;
                 clearSelection(); // Clear selection when changing views

                 if (view === 'list') {
                     mainTitle.textContent = 'Tasks'; // Update header title
                     listViewBtn.classList.add('active');
                     graphViewBtn.classList.remove('active');
                     graphViewDiv.classList.add('hidden-view');
                     // Delay removing hidden class to allow graph to slide out first
                     setTimeout(() => {
                        listViewDiv.classList.remove('hidden-view');
                        renderTaskList(); // Ensure list is rendered correctly
                     }, 50); // Small delay
                 } else { // Switching to graph
                     mainTitle.textContent = 'Graph View'; // Update header title
                     listViewBtn.classList.remove('active');
                     graphViewBtn.classList.add('active');
                     listViewDiv.classList.add('hidden-view');
                      // Delay removing hidden class to allow list to slide out first
                     setTimeout(() => {
                        graphViewDiv.classList.remove('hidden-view');
                        updateChart(); // Ensure chart is rendered/updated
                     }, 50); // Small delay
                 }
                 updateActiveNav(); // Update sidebar highlight
             }

            // --- Sidebar Navigation ---
            function updateActiveNav() {
                 navDashboardLink.classList.toggle('active', currentView === 'list');
                 navGraphLink.classList.toggle('active', currentView === 'graph');
                 // Settings is separate logic if implemented
            }

            // --- Charting ---
            function getChartData() {
                 const data = {
                     completed: 0,
                     pending: 0, // Includes today and future
                     overdue: 0,
                 };
                 const now = dayjs();
                 todos.forEach(todo => {
                     if (todo.completed) {
                         data.completed++;
                     } else {
                         if (todo.dueDate && dayjs(todo.dueDate).isBefore(now, 'day')) {
                             data.overdue++;
                         } else {
                             data.pending++; // Pending if not completed and not overdue
                         }
                     }
                 });
                 return data;
            }

             function updateChart() {
                  // Only render/update if the graph view is active AND the canvas exists
                 if (currentView !== 'graph' || !taskChartCanvas) return;

                 const chartData = getChartData();
                 const isDarkMode = body.classList.contains('dark-mode');
                 const textColor = isDarkMode ? 'var(--dm-text)' : 'var(--lm-text)';
                 const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

                 const config = {
                     type: 'doughnut',
                     data: {
                         labels: ['Pending', 'Completed', 'Overdue'],
                         datasets: [{
                             label: 'Task Status',
                             data: [chartData.pending, chartData.completed, chartData.overdue],
                             backgroundColor: [
                                 isDarkMode ? 'var(--dm-priority-medium)' : 'var(--lm-priority-medium)', // Pending - Orange/Yellow
                                 isDarkMode ? 'var(--dm-priority-low)' : 'var(--lm-priority-low)',      // Completed - Green
                                 isDarkMode ? 'var(--dm-priority-high)' : 'var(--lm-priority-high)'     // Overdue - Red
                             ],
                             borderColor: isDarkMode ? 'var(--dm-component-bg)' : 'var(--lm-component-bg)',
                             borderWidth: 3, // Slightly thicker border
                             hoverOffset: 8 // Pop out effect on hover
                         }]
                     },
                     options: {
                         responsive: true,
                         maintainAspectRatio: false, // Allow container to control aspect ratio
                         plugins: {
                             legend: {
                                 position: 'bottom', // Move legend below chart
                                 labels: {
                                     color: textColor,
                                     padding: 15, // Add padding
                                     font: { size: 13 }
                                 }
                             },
                             tooltip: {
                                 callbacks: {
                                     label: function(context) {
                                         let label = context.label || '';
                                         if (label) label += ': ';
                                         label += context.parsed;
                                         const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                         const percentage = total > 0 ? Math.round((context.parsed / total) * 100) : 0;
                                         label += ` (${percentage}%)`;
                                         return label;
                                     }
                                 }
                             },
                             title: { // Keep title? Maybe remove if obvious. Kept for now.
                                 display: false, // Hide the top title, legend is enough
                                 // text: 'Task Status Overview',
                                 // color: textColor,
                                 // font: { size: 16 }
                             }
                         },
                         animation: {
                             animateRotate: true,
                             animateScale: true,
                             duration: 800 // Slightly longer animation
                         },
                         cutout: '60%' // Make doughnut hole smaller/larger
                     }
                 };

                 if (taskChart) {
                     // Update existing chart data and colors
                     taskChart.data.datasets[0].data = config.data.datasets[0].data;
                     taskChart.data.datasets[0].backgroundColor = config.data.datasets[0].backgroundColor;
                     taskChart.data.datasets[0].borderColor = config.data.datasets[0].borderColor;
                     taskChart.options.plugins.legend.labels.color = textColor;
                     // taskChart.options.plugins.title.color = textColor; // Title hidden now
                     taskChart.update();
                 } else {
                     // Ensure canvas context exists before creating chart
                      const ctx = taskChartCanvas.getContext('2d');
                      if (ctx) {
                         taskChart = new Chart(ctx, config);
                      } else {
                         console.error("Could not get canvas context for chart.");
                      }
                 }
             }

             // Updates chart colors when theme changes
             function updateChartConfig() {
                if (taskChart) {
                    const isDarkMode = body.classList.contains('dark-mode');
                    const textColor = isDarkMode ? 'var(--dm-text)' : 'var(--lm-text)';
                     const newBgColors = [
                        isDarkMode ? 'var(--dm-priority-medium)' : 'var(--lm-priority-medium)',
                        isDarkMode ? 'var(--dm-priority-low)' : 'var(--lm-priority-low)',
                        isDarkMode ? 'var(--dm-priority-high)' : 'var(--lm-priority-high)'
                    ];
                    const newBorderColor = isDarkMode ? 'var(--dm-component-bg)' : 'var(--lm-component-bg)';

                    taskChart.options.plugins.legend.labels.color = textColor;
                    // taskChart.options.plugins.title.color = textColor; // Title hidden
                    taskChart.data.datasets[0].backgroundColor = newBgColors;
                    taskChart.data.datasets[0].borderColor = newBorderColor;
                    taskChart.update();
                 }
             }


            // --- Notifications ---
             let notificationIdCounter = 0; // Simple counter for unique IDs
             function addNotification(message, type = 'info') {
                 const timestamp = dayjs().format('h:mm A');
                 const newNotification = {
                    id: notificationIdCounter++,
                    message,
                    type,
                    timestamp,
                    isNew: true // Flag for potential styling/counting
                 };
                 notifications.unshift(newNotification); // Add to beginning
                 if (notifications.length > 30) notifications.pop(); // Limit size
                 renderNotifications();

                 // Show browser notification only for important types or based on settings
                 if (type === 'warning' || type === 'error' || type === 'success') {
                     // showBrowserNotification("Task Alert", message); // Use a generic title
                 }
             }

             function renderNotifications() {
                 notificationList.innerHTML = ''; // Clear existing
                 let unreadCount = notifications.filter(n => n.isNew).length;

                 if (notifications.length === 0) {
                    notificationList.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--muted-text);">No notifications</div>';
                    notificationBadge.classList.add('hidden');
                    return;
                 }

                 notifications.forEach(notif => {
                     const item = document.createElement('div');
                     item.classList.add('notification-item', notif.type);
                     item.dataset.id = notif.id; // Add ID for potential dismissal
                     item.innerHTML = `
                        <span class="msg">${escapeHtml(notif.message)}</span>
                        <span class="time">${notif.timestamp}</span>
                        `;
                     notificationList.appendChild(item);
                 });

                 // Update badge count (use unreadCount if implemented)
                 const countToShow = unreadCount > 0 ? unreadCount : notifications.length; // Example logic
                 if (countToShow > 0) {
                     notificationBadge.textContent = countToShow > 9 ? '9+' : countToShow;
                     notificationBadge.classList.remove('hidden');
                 } else {
                     notificationBadge.classList.add('hidden');
                 }
             }

             function markNotificationsRead() {
                 notifications.forEach(n => n.isNew = false);
                 renderNotifications(); // Re-render to update badge and potentially styling
             }

            function startNotificationChecks() {
                if (notificationCheckInterval) clearInterval(notificationCheckInterval);
                checkDueDates(); // Initial check
                // Check every minute for upcoming tasks
                notificationCheckInterval = setInterval(checkDueDates, 60 * 1000);
            }

            // Stores notified task IDs to avoid spamming
            const recentlyNotifiedTaskIds = new Set();
             function checkDueDates() {
                const now = dayjs();
                // Notify if due within the next 15 minutes
                const upcomingThreshold = now.add(15, 'minutes');

                 todos.forEach(todo => {
                     if (!todo.completed && todo.dueDate) {
                         const dueDate = dayjs(todo.dueDate);
                         // Check if due date is valid before comparing
                         if (dueDate.isValid()) {
                             const hasBeenNotified = recentlyNotifiedTaskIds.has(todo.id);

                             // Check if task is upcoming and hasn't been notified recently
                             if (dueDate.isAfter(now) && dueDate.isBefore(upcomingThreshold) && !hasBeenNotified) {
                                 const message = `Task due ${dueDate.fromNow()}: "${todo.title}"`;
                                 addNotification(message, 'warning');
                                 showBrowserNotification("Task Reminder", message);
                                 recentlyNotifiedTaskIds.add(todo.id);
                                 // Optional: Remove from set after some time to allow re-notification if task is edited/still pending
                                 setTimeout(() => recentlyNotifiedTaskIds.delete(todo.id), 60 * 60 * 1000); // Remove after 1 hour
                             }
                             // Optional: Handle overdue notifications (might be annoying)
                             // else if (dueDate.isBefore(now) && !hasBeenNotified && !todo.overdueNotified) { // Add overdueNotified flag to todo?
                             //    const message = `Task OVERDUE: "${todo.title}" (Due ${dueDate.fromNow()})`;
                             //    addNotification(message, 'error');
                             //    showBrowserNotification("Task Overdue", message);
                             //    recentlyNotifiedTaskIds.add(todo.id);
                             //    // todo.overdueNotified = true; // Mark as notified
                             // }
                         }
                     }
                 });
                 // Clean up notified set for tasks that no longer exist or are completed
                 const existingTaskIds = new Set(todos.map(t => t.id));
                 recentlyNotifiedTaskIds.forEach(id => {
                    if (!existingTaskIds.has(id)) {
                        recentlyNotifiedTaskIds.delete(id);
                    } else {
                        const task = todos.find(t => t.id === id);
                        if (task && task.completed) {
                            recentlyNotifiedTaskIds.delete(id);
                        }
                    }
                 });
             }

             function requestNotificationPermission() {
                 if ('Notification' in window && Notification.permission === 'default') {
                    console.log("Requesting notification permission...");
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                             addNotification("Browser notifications enabled.", "success");
                        } else {
                             addNotification("Browser notifications denied.", "warning");
                        }
                    });
                 }
             }

             function showBrowserNotification(title, message) {
                 if (!("Notification" in window)) {
                    console.log("Browser does not support desktop notification");
                    return;
                 }
                 if (Notification.permission === "granted") {
                    // Use service worker to show notification for better PWA experience (optional enhancement)
                    // navigator.serviceWorker.ready.then(registration => {
                    //    registration.showNotification(title, { body: message, icon: '/path/to/icon.png' });
                    // });
                    // Simple browser notification:
                     new Notification(title, { body: message, icon: 'favicon.ico' }); // Add your icon path
                 } else if (Notification.permission === 'default') {
                     // Permission not yet requested or denied, maybe re-request?
                     // Be cautious about re-requesting too often.
                      console.log("Notification permission not granted yet.");
                      requestNotificationPermission(); // Attempt request if default
                 } else {
                     // Permission denied
                     console.log("Notification permission was denied.");
                 }
             }

            // --- Event Handlers ---
            // Add Task Button
            addTaskBtn.addEventListener('click', () => {
                editTaskId = null; // Ensure it's treated as a new task
                modalTitle.textContent = 'Add Task';
                 saveTaskBtn.textContent = 'Save Task';
                taskForm.reset();
                currentModalSubtasks = []; // Clear subtasks for new task
                renderModalSubtasks();
                initializeDatepicker(); // Reset date picker for new task
                taskPriorityInput.value = 'Medium'; // Default priority
                taskRecurrenceInput.value = 'none'; // Default recurrence
                openModal(taskModal);
            });

             // Task Form Submission (Add/Edit)
            taskForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const title = taskTitleInput.value.trim();
                const description = taskDescriptionInput.value.trim();
                const priority = taskPriorityInput.value;
                // Get date from flatpickr instance, ensures correct parsing
                const selectedDates = dueDatePicker.selectedDates;
                const dueDate = selectedDates.length > 0 ? dayjs(selectedDates[0]).toISOString() : null;
                const category = taskCategoryInput.value.trim() || 'Uncategorized';
                const recurrence = taskRecurrenceInput.value;

                if (!title) {
                     addNotification("Task title cannot be empty.", "warning");
                     taskTitleInput.focus();
                     return;
                 }

                const taskData = { title, description, priority, dueDate, category, recurrence, subtasks: currentModalSubtasks }; // Include subtasks from modal

                if (editTaskId) {
                    updateTask(editTaskId, taskData);
                } else {
                    addTask(taskData);
                }
                closeModal(taskModal);
             });

            // Theme Toggle
            themeToggleBtn.addEventListener('click', toggleTheme);

             // Filter Buttons
             filterBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    setActiveFilter(btn.dataset.filter);
                });
            });

            // View Switcher Buttons & Sidebar Links
            listViewBtn.addEventListener('click', () => switchView('list'));
            graphViewBtn.addEventListener('click', () => switchView('graph'));
            navDashboardLink.addEventListener('click', (e) => { e.preventDefault(); switchView('list'); });
            navGraphLink.addEventListener('click', (e) => { e.preventDefault(); switchView('graph'); });
            navSettingsLink.addEventListener('click', (e) => {
                 e.preventDefault();
                 addNotification("Settings page is not implemented yet.", "info");
             });


            // Edit Task (Function called from renderTaskItem)
            function editTask(id) {
                const task = todos.find(todo => todo.id === id);
                if (!task) {
                     console.error("Edit failed: Task ID not found", id);
                     addNotification("Could not find the task to edit.", "error");
                     return;
                 }

                editTaskId = id;
                modalTitle.textContent = 'Edit Task';
                 saveTaskBtn.textContent = 'Update Task';
                taskForm.reset(); // Clear previous state

                taskIdInput.value = task.id;
                taskTitleInput.value = task.title;
                taskDescriptionInput.value = task.description || '';
                taskPriorityInput.value = task.priority;
                taskCategoryInput.value = task.category || '';
                taskRecurrenceInput.value = task.recurrence || 'none';

                 // Set date picker value using flatpickr's API
                 if (task.dueDate && dayjs(task.dueDate).isValid()) {
                      // Flatpickr needs the date object or a string it can parse
                     dueDatePicker.setDate(task.dueDate, true); // setDate(date, triggerChange, format)
                 } else {
                     dueDatePicker.clear();
                 }

                 // Load subtasks into the modal editor (create a deep copy)
                 currentModalSubtasks = JSON.parse(JSON.stringify(task.subtasks || []));
                 renderModalSubtasks();

                openModal(taskModal);
            }

            // Export/Import
            exportTasksBtn.addEventListener('click', () => {
                if (todos.length === 0) {
                    addNotification("No tasks to export.", "warning");
                    return;
                }
                 // Use a deep copy to avoid modifying original state during stringification
                const todosToExport = JSON.parse(JSON.stringify(todos));
                // Clean up runtime state like timer intervals before export
                // (already handled in saveTodos logic, which prepares clean data)
                const dataStr = JSON.stringify(todosToExport, null, 2); // Pretty print JSON

                const dataBlob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `todos_export_${dayjs().format('YYYYMMDD_HHmmss')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                addNotification("Tasks exported successfully.", "success");
            });

            importTasksInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);

                        // Check if it's an array (basic validation)
                        if (!Array.isArray(importedData)) {
                             throw new Error("Invalid file format: Expected an array of tasks.");
                        }

                         // Deeper validation and sanitization
                         const validTodos = importedData.map((t, index) => {
                            if (!t || typeof t !== 'object') throw new Error(`Invalid data at index ${index}: Not an object.`);
                             // Provide defaults and ensure correct types
                             return {
                                 id: t.id || `imported-${Date.now()}-${index}`, // Generate ID if missing
                                 title: String(t.title || 'Untitled Imported Task'),
                                 description: String(t.description || ''),
                                 priority: ['High', 'Medium', 'Low'].includes(t.priority) ? t.priority : 'Medium',
                                 dueDate: t.dueDate && dayjs(t.dueDate).isValid() ? dayjs(t.dueDate).toISOString() : null,
                                 completed: Boolean(t.completed || false),
                                 category: String(t.category || 'Uncategorized'),
                                 recurrence: ['none', 'daily', 'weekly', 'monthly'].includes(t.recurrence) ? t.recurrence : 'none',
                                 subtasks: Array.isArray(t.subtasks) ? t.subtasks.map((st, subIndex) => ({
                                     id: st.id || `imported-sub-${Date.now()}-${index}-${subIndex}`,
                                     text: String(st.text || 'Untitled Subtask'),
                                     completed: Boolean(st.completed || false)
                                 })) : [],
                                 accumulatedTime: Number(t.accumulatedTime) || 0,
                                 // Reset runtime timer state on import
                                 isTimerRunning: false,
                                 startTime: null
                             };
                         }).filter(t => t.title); // Filter out any completely invalid entries

                        if (validTodos.length === 0 && importedData.length > 0) {
                             throw new Error("No valid tasks found in the imported file.");
                        }

                        // Confirm replacement with user
                        openConfirmModal(`Import ${validTodos.length} tasks? This will REPLACE all current tasks.`, () => {
                             todos = validTodos;
                             stopAllTimers(); // Stop any running timers before replacing data
                             timers = {}; // Clear timer intervals map
                             clearSelection(); // Clear current selection
                             saveTodos(); // Save the newly imported tasks
                             renderAll(); // Render the new task list
                             addNotification(`${validTodos.length} tasks imported successfully.`, 'success');
                             event.target.value = null; // Reset file input for potential re-import
                        });

                    } catch (error) {
                        console.error("Import Error:", error);
                        addNotification(`Import failed: ${error.message}`, 'error');
                        event.target.value = null; // Reset file input
                    }
                };
                reader.onerror = () => {
                    addNotification('Error reading file.', 'error');
                    event.target.value = null; // Reset file input
                };
                reader.readAsText(file);
            });

             // Modal Subtask Add Button & Enter Key
            addSubtaskBtnModal.addEventListener('click', addSubtaskToModal);
            newSubtaskTextInput.addEventListener('keypress', (e) => {
                 if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent potential form submission
                    addSubtaskToModal();
                 }
            });

            // Batch Action Buttons
            batchDeleteBtn.addEventListener('click', batchDelete);
            batchCompleteBtn.addEventListener('click', () => batchToggleComplete(true));
            batchUncompleteBtn.addEventListener('click', () => batchToggleComplete(false));


            // --- General UI Handlers ---
            // Notification Panel Toggle
            notificationBtn.addEventListener('click', (e) => {
                 e.stopPropagation(); // Prevent window click listener from closing it immediately
                 const isVisible = notificationList.style.display === 'block';
                 notificationList.style.display = isVisible ? 'none' : 'block';
                 if (!isVisible) {
                    // Mark notifications as read when opened
                    markNotificationsRead();
                 }
            });

            // Refresh Button
            refreshBtn.addEventListener('click', () => {
                 addNotification('View refreshed.', 'info');
                 // Re-load might be too disruptive, just re-render
                 stopAllTimers(); // Stop timers
                 timers = {}; // Clear timer references
                 loadTodos(); // Reload data from storage (including timer state)
                 renderAll(); // Re-render everything based on loaded state
                 startNotificationChecks(); // Restart checks
                 startTotalTimerInterval(); // Restart total timer updates
            });

             // Logout Button (Placeholder)
             logoutBtn.addEventListener('click', () => {
                 openConfirmModal("Are you sure you want to log out? (This is a demo - data is stored locally in this browser)", () => {
                     addNotification("Logout action placeholder.", "info");
                     // In a real app: clear session/token, redirect to login page, etc.
                 });
             });

             // Close popups/modals on clicks outside or Escape key
            window.addEventListener('click', (e) => {
                 // Close notification list if click is outside the button wrapper and the list itself
                 if (!notificationBtnWrapper.contains(e.target) && !notificationList.contains(e.target)) {
                     if (notificationList.style.display === 'block') {
                        notificationList.style.display = 'none';
                     }
                 }
                 // Close OPEN modals on overlay click (click directly on the .modal element)
                 if (e.target.classList.contains('modal') && e.target.style.display === 'flex') {
                    closeModal(e.target);
                 }
            });

            window.addEventListener('keydown', (e) => {
                 // Close modals/popups on Escape
                 if (e.key === 'Escape') {
                    let modalClosed = false;
                    document.querySelectorAll('.modal').forEach(m => {
                        if (m.style.display === 'flex') {
                            closeModal(m);
                            modalClosed = true;
                         }
                    });
                     // If a modal wasn't closed, maybe close the notification list
                    if (!modalClosed && notificationList.style.display === 'block') {
                        notificationList.style.display = 'none';
                     }
                     // If selection active, clear selection on escape?
                     if (!modalClosed && selectedTaskIds.size > 0) {
                        clearSelection();
                     }
                 }

                 // Keyboard Shortcuts (using Ctrl+Alt to minimize browser conflicts)
                 if (e.ctrlKey && e.altKey) {
                    switch (e.key.toLowerCase()) {
                        case 'n': // Ctrl+Alt+N for New Task
                             e.preventDefault();
                             addTaskBtn.click();
                             break;
                        case 's': // Ctrl+Alt+S for Save/Update Task (if modal is open)
                             if (taskModal.style.display === 'flex') {
                                 e.preventDefault();
                                 taskForm.requestSubmit(); // Use form submission trigger
                             }
                             break;
                         case 'l': // Ctrl+Alt+L for List View
                            e.preventDefault();
                            listViewBtn.click();
                            break;
                        case 'g': // Ctrl+Alt+G for Graph View
                            e.preventDefault();
                            graphViewBtn.click();
                            break;
                         // Add more shortcuts as needed (e.g., Ctrl+Alt+F to focus search/filter?)
                    }
                 }
            });

            // Stop timers and save state before unloading page
            window.addEventListener('beforeunload', (event) => {
                 console.log("beforeunload event triggered");
                 stopAllTimers(); // Ensure time is calculated and saved before closing
                 // Note: 'beforeunload' doesn't guarantee saving completes, but it's the best place to try.
            });

            // --- Utility ---
            function escapeHtml(unsafe) {
                if (typeof unsafe !== 'string') return "";
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

        }); // End DOMContentLoaded
    </script>
</body>
</html>
