<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced To-Do App</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
        :root {
            /* --- Light Mode --- */
            --lm-page-bg-start: #f8f9fa; /* Lighter background */
            --lm-page-bg-end: #e9ecef;
            --lm-component-bg: #ffffff;
            --lm-text: #212529;
            --lm-muted-text: #6c757d;
            --lm-border: #dee2e6;
            --lm-input-bg: #f8f9fa;
            --lm-input-border: #ced4da;
            --lm-shadow-color: rgba(0, 0, 0, 0.1);
            --lm-header-bg: #ffffff;
            --lm-task-bg: #ffffff;
            --lm-task-selected-bg: #cfe2ff; /* Lighter blue for selection */
            --lm-task-completed-bg: #d1e7dd; /* Lighter green for completed */
            --lm-subtask-bg: #f8f9fa;
            --lm-primary: #0d6efd;  /* Bootstrap Blue */
            --lm-secondary: #6c757d;
            --lm-success: #198754;  /* Bootstrap Green */
            --lm-danger: #dc3545;   /* Bootstrap Red */
            --lm-warning: #ffc107;  /* Bootstrap Yellow */
            --lm-info: #0dcaf0;     /* Bootstrap Cyan */
            --lm-tag-high-bg: rgba(220, 53, 69, 0.1);
            --lm-tag-medium-bg: rgba(13, 110, 253, 0.1);
            --lm-tag-low-bg: rgba(108, 117, 125, 0.1);
            --lm-tag-high-text: var(--lm-danger);
            --lm-tag-medium-text: var(--lm-primary);
            --lm-tag-low-text: var(--lm-secondary);
            --lm-alert-expired-bg: rgba(220, 53, 69, 0.1);
            --lm-alert-expired-text: var(--lm-danger);
            --lm-alert-upcoming-bg: rgba(255, 193, 7, 0.1);
            --lm-alert-upcoming-text: #b58900;
            --lm-timer-active-color: var(--lm-success);
            --lm-total-timer-bg: #e9ecef;

            /* --- Dark Mode --- */
            --dm-page-bg-start: #1a1a1a;
            --dm-page-bg-end: #2c2c2c;
            --dm-component-bg: #343a40;
            --dm-text: #f8f9fa;
            --dm-muted-text: #adb5bd;
            --dm-border: #495057;
            --dm-input-bg: #495057;
            --dm-input-border: #6c757d;
            --dm-shadow-color: rgba(0, 0, 0, 0.4);
            --dm-header-bg: #343a40;
            --dm-task-bg: #495057;
            --dm-task-selected-bg: #0d6efd40; /* Blue with alpha */
            --dm-task-completed-bg: #19875440; /* Green with alpha */
            --dm-subtask-bg: #343a40;
            --dm-primary: #6ea8fe; /* Lighter Blue */
            --dm-secondary: #adb5bd;
            --dm-success: #75b798; /* Lighter Green */
            --dm-danger: #f17c7c;  /* Lighter Red */
            --dm-warning: #ffd66b; /* Lighter Yellow */
            --dm-info: #6edff6;    /* Lighter Cyan */
            --dm-tag-high-bg: rgba(241, 124, 124, 0.2);
            --dm-tag-medium-bg: rgba(110, 168, 254, 0.2);
            --dm-tag-low-bg: rgba(173, 181, 189, 0.2);
            --dm-tag-high-text: var(--dm-danger);
            --dm-tag-medium-text: var(--dm-primary);
            --dm-tag-low-text: var(--dm-secondary);
            --dm-alert-expired-bg: rgba(241, 124, 124, 0.2);
            --dm-alert-expired-text: var(--dm-danger);
            --dm-alert-upcoming-bg: rgba(255, 214, 107, 0.2);
            --dm-alert-upcoming-text: var(--dm-warning);
            --dm-timer-active-color: var(--dm-success);
            --dm-total-timer-bg: #495057;

            /* --- General --- */
            --border-radius: 8px;
            --transition-speed: 0.3s;
            --notification-bg: rgba(10, 10, 10, 0.9);
            --notification-text: white;
        }

        /* --- Base Styles --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html { font-size: 16px; }

        body {
            background: linear-gradient(135deg, var(--lm-page-bg-start), var(--lm-page-bg-end));
            min-height: 100vh;
            color: var(--lm-text);
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        /* Class added when app view is active */
        body.app-view {
            display: block;
            padding: 0;
        }
        /* Class added when login view is active */
        body.login-view {
            display: flex; /* Use flex to center login container */
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }


        body.dark-mode {
            background: linear-gradient(135deg, var(--dm-page-bg-start), var(--dm-page-bg-end));
            color: var(--dm-text);
        }

        /* --- Utility Classes --- */
        .hidden { display: none !important; }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        .fade-in { animation: fadeInAnimation 0.5s ease-out forwards; }
        .fade-out { animation: fadeOutAnimation 0.5s ease-in forwards; }
        .slide-down { animation: slideDownAnimation 0.4s ease-out forwards; }

        @keyframes fadeInAnimation { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOutAnimation { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideDownAnimation { from { opacity: 0; transform: translateY(-15px); } to { opacity: 1; transform: translateY(0); } }


        /* --- Component Styling (Defaults to Light Mode) --- */
        .login-container, .modal-content, header, .stat-card, .progress-item,
        .todo-section, .graph-item, .insight-card, .notification-list,
        .distribution-item, .batch-actions-bar, .total-timer-display {
            background-color: var(--lm-component-bg);
            border: 1px solid var(--lm-border);
            box-shadow: 0 4px 12px var(--lm-shadow-color);
            color: var(--lm-text);
            border-radius: var(--border-radius);
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        /* --- Dark Mode Component Overrides --- */
        body.dark-mode .login-container, body.dark-mode .modal-content, body.dark-mode .stat-card,
        body.dark-mode .progress-item, body.dark-mode .todo-section, body.dark-mode .graph-item,
        body.dark-mode .insight-card, body.dark-mode .notification-list,
        body.dark-mode .distribution-item, body.dark-mode .batch-actions-bar,
        body.dark-mode .total-timer-display {
             background-color: var(--dm-component-bg);
             border-color: var(--dm-border);
             box-shadow: 0 4px 12px var(--dm-shadow-color);
             color: var(--dm-text);
        }
        body.dark-mode header {
            background-color: var(--dm-header-bg);
            border-color: var(--dm-border);
            box-shadow: 0 4px 12px var(--dm-shadow-color);
            color: var(--dm-text);
        }

        /* --- Login Page --- */
        /* login-page class is now on body */
        .login-container {
            padding: 2rem;
            width: 100%;
            max-width: 450px;
            text-align: center;
            display: none; /* Hidden by default, shown via JS */
        }
        body.login-view .login-container {
            display: block; /* Show when body has login-view class */
            animation: fadeInAnimation 0.5s ease-out; /* Optional fade-in */
        }

        .login-title { font-size: 1.75rem; margin-bottom: 1.5rem; color: inherit; }
        .input-group { margin-bottom: 1.25rem; text-align: left; }
        .input-group label {
            display: block; margin-bottom: 0.5rem; font-weight: 500;
            color: var(--lm-muted-text); font-size: 0.9rem;
            transition: color var(--transition-speed) ease;
        }
        body.dark-mode .input-group label { color: var(--dm-muted-text); }

        .input-field, .filter-select, .filter-date, .sort-select, select, textarea {
            width: 100%; padding: 0.75rem 1rem; border-radius: var(--border-radius);
            border: 1px solid var(--lm-input-border); font-size: 1rem; outline: none;
            background-color: var(--lm-input-bg); color: var(--lm-text); line-height: 1.5;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        .input-field::placeholder, .filter-date::placeholder, textarea::placeholder { color: var(--lm-muted-text); opacity: 0.7; }
        .input-field:focus, .filter-select:focus, .filter-date:focus, .sort-select:focus, select:focus, textarea:focus {
            border-color: var(--lm-primary); box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25);
        }
        body.dark-mode .input-field, body.dark-mode .filter-select, body.dark-mode .filter-date,
        body.dark-mode .sort-select, body.dark-mode select, body.dark-mode textarea {
            background-color: var(--dm-input-bg); color: var(--dm-text); border-color: var(--dm-input-border);
        }
         body.dark-mode .input-field::placeholder, body.dark-mode .filter-date::placeholder, body.dark-mode textarea::placeholder { color: var(--dm-muted-text); opacity: 0.7; }
         body.dark-mode .input-field:focus, body.dark-mode .filter-select:focus, body.dark-mode .filter-date:focus,
         body.dark-mode .sort-select:focus, body.dark-mode select:focus, body.dark-mode textarea:focus {
            border-color: var(--dm-primary); box-shadow: 0 0 0 3px rgba(110, 168, 254, 0.25);
        }
        textarea { resize: vertical; min-height: 80px; }
        .flatpickr-input { cursor: pointer; background-color: var(--lm-input-bg) !important; } /* Override flatpickr */
        body.dark-mode .flatpickr-input { background-color: var(--dm-input-bg) !important; }

        /* --- Button Styles --- */
        .btn {
            padding: 0.65rem 1.25rem; border: none; border-radius: var(--border-radius);
            font-size: 0.9rem; cursor: pointer; font-weight: 600;
            transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 2px 4px var(--lm-shadow-color);
            line-height: 1.5; text-align: center; display: inline-flex; align-items: center; justify-content: center; gap: 0.5em;
            white-space: nowrap;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px var(--lm-shadow-color); }
        .btn:active { transform: translateY(0); box-shadow: 0 1px 2px var(--lm-shadow-color); }
        .btn:disabled { opacity: 0.65; cursor: not-allowed; transform: none; box-shadow: none; }

        /* Light Mode Buttons */
        .btn-primary { background-color: var(--lm-primary); color: white; }
        .btn-secondary { background-color: var(--lm-secondary); color: white; }
        .btn-success { background-color: var(--lm-success); color: white; }
        .btn-danger { background-color: var(--lm-danger); color: white; }
        .btn-warning { background-color: var(--lm-warning); color: black; }
        .btn-info { background-color: var(--lm-info); color: black; }
        .btn-light { background-color: var(--lm-component-bg); color: var(--lm-text); border: 1px solid var(--lm-border); }
        .btn-outline-primary { background-color: transparent; color: var(--lm-primary); border: 1px solid var(--lm-primary); }
        .btn-outline-primary:hover { background-color: var(--lm-primary); color: white; }
        .btn-outline-danger { background-color: transparent; color: var(--lm-danger); border: 1px solid var(--lm-danger); }
        .btn-outline-danger:hover { background-color: var(--lm-danger); color: white; }
        .btn-icon { padding: 0.5rem; font-size: 1rem; line-height: 1; } /* Smaller padding for icon-only buttons */
        .btn-icon i { margin: 0; } /* Remove margin for icon-only */

        /* Dark Mode Buttons */
        body.dark-mode .btn-primary { background-color: var(--dm-primary); color: #111; } /* Better contrast */
        body.dark-mode .btn-secondary { background-color: var(--dm-secondary); color: #111; }
        body.dark-mode .btn-success { background-color: var(--dm-success); color: #111; }
        body.dark-mode .btn-danger { background-color: var(--dm-danger); color: #111; }
        body.dark-mode .btn-warning { background-color: var(--dm-warning); color: #111; }
        body.dark-mode .btn-info { background-color: var(--dm-info); color: #111; }
        body.dark-mode .btn-light { background-color: var(--dm-component-bg); color: var(--dm-text); border: 1px solid var(--dm-border); }
        body.dark-mode .btn-outline-primary { color: var(--dm-primary); border-color: var(--dm-primary); }
        body.dark-mode .btn-outline-primary:hover { background-color: var(--dm-primary); color: #111; }
        body.dark-mode .btn-outline-danger { color: var(--dm-danger); border-color: var(--dm-danger); }
        body.dark-mode .btn-outline-danger:hover { background-color: var(--dm-danger); color: #111; }
        body.dark-mode .btn { box-shadow: 0 2px 4px var(--dm-shadow-color); }
        body.dark-mode .btn:hover { box-shadow: 0 4px 8px var(--dm-shadow-color); }
        body.dark-mode .btn:active { box-shadow: 0 1px 2px var(--dm-shadow-color); }

        .btn-block { display: block; width: 100%; }
        .register-link { margin-top: 1.25rem; color: var(--lm-muted-text); font-size: 0.9rem; }
        body.dark-mode .register-link { color: var(--dm-muted-text); }
        .register-link a { color: var(--lm-primary); text-decoration: none; font-weight: 500; cursor: pointer; } /* Make link look clickable */
        body.dark-mode .register-link a { color: var(--dm-primary); }
        .register-link a:hover { text-decoration: underline; }

        /* --- Modal Styles --- */
        .modal {
            display: none; /* Initially hidden */
            position: fixed; z-index: 1050; /* High z-index */
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center; align-items: center;
            backdrop-filter: blur(3px);
            padding: 1rem;
            overflow-y: auto; /* Allow modal itself to scroll if content overflows */
        }
        .modal.show { display: flex; animation: fadeIn 0.3s ease-out; }
        .modal-content {
            border-radius: var(--border-radius); padding: 1.5rem 2rem;
            width: 100%; max-width: 600px; /* Wider for more fields */
            max-height: 90vh; /* Limit height */
            overflow-y: auto; /* Scroll INSIDE the content area */
            animation: slideDownAnimation 0.4s ease-out;
            position: relative; /* For close button */
        }
        /* Specific width for confirmation/registration modals */
        #confirmationModal .modal-content,
        #registrationModal .modal-content {
            max-width: 450px;
        }

        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 1.5rem; padding-bottom: 1rem;
            border-bottom: 1px solid var(--lm-border);
        }
        body.dark-mode .modal-header { border-bottom-color: var(--dm-border); }
        .modal-title { font-size: 1.4rem; font-weight: 600; color: inherit; margin: 0; }
        .modal-close-btn {
            background: none; border: none; font-size: 1.8rem; cursor: pointer;
            color: var(--lm-muted-text); padding: 0.2rem; line-height: 1;
            transition: color var(--transition-speed) ease;
        }
        .modal-close-btn:hover { color: var(--lm-danger); }
        body.dark-mode .modal-close-btn { color: var(--dm-muted-text); }
        body.dark-mode .modal-close-btn:hover { color: var(--dm-danger); }

        .modal-body { margin-bottom: 1.5rem; }
        .modal-footer {
             margin-top: 1.5rem; padding-top: 1rem;
             display: flex; justify-content: flex-end; gap: 0.75rem;
             border-top: 1px solid var(--lm-border);
        }
        body.dark-mode .modal-footer { border-top-color: var(--dm-border); }
        .modal-footer .btn-secondary { background-color: var(--lm-secondary); color: white; } /* Explicit style for cancel */
        body.dark-mode .modal-footer .btn-secondary { background-color: var(--dm-secondary); color: #111; }

        /* --- App Layout & Header --- */
        .app-container {
            display: none; /* Hidden by default, shown via JS */
            width: 100%;
            min-height: 100vh;
        }
         body.app-view .app-container {
            display: block; /* Show when body has app-view class */
        }

        header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.75rem 1.5rem; position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--lm-border);
        }
        body.dark-mode header { border-bottom-color: var(--dm-border); }

        .logo {
            font-size: 1.5rem; font-weight: 700; color: var(--lm-primary);
            cursor: pointer; text-decoration: none;
            transition: color var(--transition-speed) ease;
        }
        body.dark-mode .logo { color: var(--dm-primary); }
        .logo i { margin-right: 0.5rem; }

        .header-actions { display: flex; align-items: center; gap: 0.75rem; }

        /* Total Timer Display */
        .total-timer-display {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: var(--lm-total-timer-bg);
        }
        body.dark-mode .total-timer-display {
            background-color: var(--dm-total-timer-bg);
        }
        .total-timer-display i { color: var(--lm-primary); }
        body.dark-mode .total-timer-display i { color: var(--dm-primary); }
        #total-timer-value { font-weight: 600; }

        /* Theme Toggle */
        .theme-toggle {
            background: none; border: none; font-size: 1.4rem; cursor: pointer;
            color: var(--lm-muted-text); padding: 0.3rem; line-height: 1;
             transition: color var(--transition-speed) ease;
        }
        .theme-toggle:hover { color: var(--lm-warning); }
        body.dark-mode .theme-toggle { color: var(--dm-muted-text); }
        body.dark-mode .theme-toggle:hover { color: var(--dm-warning); }

        /* Notification Bell */
        .notification-bell { position: relative; }
        #notificationBtn {
            background: none; border: none; font-size: 1.4rem; cursor: pointer;
            color: var(--lm-muted-text); padding: 0.3rem; line-height: 1;
            transition: color var(--transition-speed) ease;
        }
        #notificationBtn:hover { color: var(--lm-info); }
        body.dark-mode #notificationBtn { color: var(--dm-muted-text); }
        body.dark-mode #notificationBtn:hover { color: var(--dm-info); }
        #notification-count {
            position: absolute; top: -5px; right: -8px;
            background-color: var(--lm-danger); color: white;
            border-radius: 50%; font-size: 0.7rem; font-weight: bold;
            padding: 2px 5px; line-height: 1; min-width: 16px; text-align: center;
        }
        body.dark-mode #notification-count { background-color: var(--dm-danger); }

        /* Notification List */
        .notification-list {
            display: none; position: absolute; top: 100%; right: 0;
            width: 300px; max-height: 400px; overflow-y: auto;
            padding: 0.5rem 0; margin-top: 0.5rem;
            z-index: 1010; border-radius: var(--border-radius);
        }
        .notification-item {
            padding: 0.75rem 1rem; font-size: 0.9rem;
            border-bottom: 1px solid var(--lm-border); cursor: pointer;
            display: flex; align-items: center; gap: 0.75rem;
            transition: background-color var(--transition-speed) ease;
        }
        .notification-item:last-child { border-bottom: none; }
        .notification-item:hover { background-color: var(--lm-page-bg-end); }
        body.dark-mode .notification-item { border-bottom-color: var(--dm-border); }
        body.dark-mode .notification-item:hover { background-color: var(--dm-page-bg-end); }
        .notification-item i { font-size: 1.1rem; width: 20px; text-align: center; }
        .notification-item.info i { color: var(--lm-info); }
        .notification-item.success i { color: var(--lm-success); }
        .notification-item.warning i { color: var(--lm-warning); }
        .notification-item.error i { color: var(--lm-danger); }
        body.dark-mode .notification-item.info i { color: var(--dm-info); }
        body.dark-mode .notification-item.success i { color: var(--dm-success); }
        body.dark-mode .notification-item.warning i { color: var(--dm-warning); }
        body.dark-mode .notification-item.error i { color: var(--dm-danger); }
        .notification-empty { padding: 1rem; text-align: center; color: var(--lm-muted-text); font-style: italic; }
        body.dark-mode .notification-empty { color: var(--dm-muted-text); }


        /* --- Main Content Area --- */
        main { padding: 1.5rem; max-width: 1200px; margin: 0 auto; }

        /* --- Dashboard Section --- */
        .dashboard-section {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem; margin-bottom: 2rem;
        }
        .stat-card { padding: 1.5rem; text-align: center; }
        .stat-icon { font-size: 2rem; margin-bottom: 0.75rem; color: var(--lm-primary); }
        body.dark-mode .stat-icon { color: var(--dm-primary); }
        .stat-value { font-size: 1.75rem; font-weight: 600; margin-bottom: 0.25rem; }
        .stat-label { font-size: 0.9rem; color: var(--lm-muted-text); }
        body.dark-mode .stat-label { color: var(--dm-muted-text); }

        /* --- To-Do Section --- */
        .todo-section { padding: 1.5rem; margin-bottom: 2rem; }
        .todo-header {
            display: flex; flex-wrap: wrap; /* Allow wrapping on small screens */
            justify-content: space-between; align-items: center;
            margin-bottom: 1rem; padding-bottom: 1rem;
            border-bottom: 1px solid var(--lm-border);
            gap: 1rem; /* Space between title and view switcher */
        }
        body.dark-mode .todo-header { border-bottom-color: var(--dm-border); }
        .todo-title { font-size: 1.5rem; font-weight: 600; margin: 0; }
        .view-switcher { display: flex; gap: 0.5rem; }
        .view-switcher .btn { padding: 0.5rem 1rem; font-size: 0.85rem; }

        /* NEW: Action Buttons Container */
        .action-buttons-container {
            display: flex; flex-wrap: wrap; gap: 0.75rem;
            margin-bottom: 1.5rem; /* Space below buttons */
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--lm-border);
        }
         body.dark-mode .action-buttons-container { border-bottom-color: var(--dm-border); }
         .action-buttons-container .btn { flex-grow: 1; /* Allow buttons to grow */ }
         @media (min-width: 576px) {
            .action-buttons-container .btn { flex-grow: 0; } /* Prevent growing on larger screens */
         }


        /* Filters and Sorting */
        .filters-and-sorting {
            display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;
            margin-bottom: 1.5rem;
        }
        .filter-group, .sort-group { display: flex; flex-direction: column; gap: 0.3rem; flex-grow: 1; min-width: 150px; }
        .filter-group label, .sort-group label {
            font-size: 0.85rem; font-weight: 500; color: var(--lm-muted-text);
        }
        body.dark-mode .filter-group label, body.dark-mode .sort-group label { color: var(--dm-muted-text); }
        .filter-select, .filter-date, .sort-select { padding: 0.5rem 0.75rem; font-size: 0.9rem; }
        #resetFiltersBtn { align-self: flex-end; /* Align button nicely */ }

        /* Batch Actions Bar */
        .batch-actions-bar {
            display: none; /* Hidden by default */
            padding: 0.75rem 1rem; margin-bottom: 1rem;
            border: 1px solid var(--lm-primary); /* Highlight bar */
            background-color: var(--lm-task-selected-bg); /* Use selection color */
            align-items: center; justify-content: space-between; gap: 1rem;
            animation: fadeInAnimation 0.3s ease;
        }
        body.dark-mode .batch-actions-bar {
             border-color: var(--dm-primary);
             background-color: var(--dm-task-selected-bg);
        }
        .batch-actions-bar span { font-size: 0.9rem; font-weight: 500; }
        .batch-actions-buttons { display: flex; gap: 0.5rem; }
        .batch-actions-buttons .btn { padding: 0.4rem 0.8rem; font-size: 0.8rem; }


        /* Task List */
        .task-list-container {
            margin-top: 1rem;
            /* Add transition for view switching */
            transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease;
            opacity: 1;
            transform: translateY(0);
        }
        .task-list-container.view-hidden {
            opacity: 0;
            transform: translateY(10px);
            position: absolute; /* Take out of flow during transition */
            pointer-events: none; /* Prevent interaction when hidden */
        }

        .task-list { list-style: none; padding: 0; margin: 0; }
        .task-item {
             background-color: var(--lm-task-bg);
             border: 1px solid var(--lm-border);
             box-shadow: 0 2px 5px var(--lm-shadow-color);
             color: var(--lm-text);
             border-left: 5px solid var(--lm-secondary); /* Default pending */
             border-radius: var(--border-radius);
             margin-bottom: 1rem; padding: 1rem;
             display: flex; align-items: flex-start; /* Align items to top */
             gap: 1rem;
             position: relative; /* For absolute positioned elements like alerts */
             transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, box-shadow 0.2s ease, transform 0.2s ease;
             cursor: pointer; /* Indicate clickable */
        }
        .task-item:hover {
            box-shadow: 0 4px 8px var(--lm-shadow-color);
            transform: translateY(-2px);
        }
        body.dark-mode .task-item {
             background-color: var(--dm-task-bg);
             border-color: var(--dm-border);
             box-shadow: 0 2px 5px var(--dm-shadow-color);
             color: var(--dm-text);
             border-left-color: var(--dm-secondary);
        }
         body.dark-mode .task-item:hover {
            box-shadow: 0 4px 8px var(--dm-shadow-color);
        }

        /* Task Selection Checkbox */
        .task-select-checkbox {
             margin-top: 2px; /* Align better with text */
             cursor: pointer;
             accent-color: var(--lm-primary); /* Style checkbox color */
             width: 18px; height: 18px;
        }
        body.dark-mode .task-select-checkbox { accent-color: var(--dm-primary); }

        .task-content { flex-grow: 1; }
        .task-main-info { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem; gap: 0.5rem; flex-wrap: wrap; }
        .task-title { font-weight: 600; font-size: 1.05rem; margin: 0; word-break: break-word; }
        .task-due-date { font-size: 0.85rem; color: var(--lm-muted-text); white-space: nowrap; }
        body.dark-mode .task-due-date { color: var(--dm-muted-text); }
        .task-due-date.overdue { color: var(--lm-danger); font-weight: 500; }
        .task-due-date.today { color: var(--lm-warning); font-weight: 500; }
        body.dark-mode .task-due-date.overdue { color: var(--dm-danger); }
        body.dark-mode .task-due-date.today { color: var(--dm-warning); }

        .task-description { font-size: 0.9rem; color: var(--lm-muted-text); margin-bottom: 0.75rem; word-break: break-word; }
        body.dark-mode .task-description { color: var(--dm-muted-text); }

        .task-meta { display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; font-size: 0.8rem; margin-bottom: 0.75rem; }
        .task-priority, .task-category, .task-recurrence {
            padding: 0.2rem 0.6rem; border-radius: 1rem; /* Pill shape */
            font-weight: 500; display: inline-flex; align-items: center; gap: 0.3em;
        }
        .task-priority.high { background-color: var(--lm-tag-high-bg); color: var(--lm-tag-high-text); }
        .task-priority.medium { background-color: var(--lm-tag-medium-bg); color: var(--lm-tag-medium-text); }
        .task-priority.low { background-color: var(--lm-tag-low-bg); color: var(--lm-tag-low-text); }
        body.dark-mode .task-priority.high { background-color: var(--dm-tag-high-bg); color: var(--dm-tag-high-text); }
        body.dark-mode .task-priority.medium { background-color: var(--dm-tag-medium-bg); color: var(--dm-tag-medium-text); }
        body.dark-mode .task-priority.low { background-color: var(--dm-tag-low-bg); color: var(--dm-tag-low-text); }

        .task-category { background-color: var(--lm-tag-low-bg); color: var(--lm-tag-low-text); } /* Default category style */
        body.dark-mode .task-category { background-color: var(--dm-tag-low-bg); color: var(--dm-tag-low-text); }
        /* Add more specific category styles if needed */

        .task-recurrence { background-color: var(--lm-info); color: white; opacity: 0.8; }
        body.dark-mode .task-recurrence { background-color: var(--dm-info); color: #111; }

        .task-timer { display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; }
        .timer-status { font-weight: 500; }
        .timer-status.active { color: var(--lm-timer-active-color); }
        body.dark-mode .timer-status.active { color: var(--dm-timer-active-color); }
        .timer-toggle-btn { padding: 0.3rem 0.6rem; font-size: 0.75rem; }

        .task-actions { display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-end; }
        .task-actions .btn { padding: 0.4rem 0.7rem; font-size: 0.8rem; }
        .task-actions .btn-icon { font-size: 0.9rem; } /* Slightly smaller icons in actions */

        /* Task Item States */
        .task-item.selected {
            background-color: var(--lm-task-selected-bg);
            border-left-color: var(--lm-primary);
        }
        .task-item.completed {
             background-color: var(--lm-task-completed-bg);
             border-left-color: var(--lm-success);
             opacity: 0.7; /* Dim completed tasks */
        }
         .task-item.completed .task-title { text-decoration: line-through; color: var(--lm-muted-text); }
         .task-item.completed .task-description { text-decoration: line-through; }
         .task-item.completed:hover { opacity: 0.8; }

        .task-item.completed.selected {
             background-color: color-mix(in srgb, var(--lm-task-completed-bg), var(--lm-task-selected-bg) 50%);
             border-left-color: var(--lm-primary);
             opacity: 0.8;
        }

        body.dark-mode .task-item.selected {
            background-color: var(--dm-task-selected-bg);
            border-left-color: var(--dm-primary);
        }
        body.dark-mode .task-item.completed {
             background-color: var(--dm-task-completed-bg);
             border-left-color: var(--dm-success);
             opacity: 0.6;
        }
         body.dark-mode .task-item.completed .task-title { color: var(--dm-muted-text); }
         body.dark-mode .task-item.completed:hover { opacity: 0.7; }
        body.dark-mode .task-item.completed.selected {
             background-color: color-mix(in srgb, var(--dm-task-completed-bg), var(--dm-task-selected-bg) 50%);
             border-left-color: var(--dm-primary);
             opacity: 0.7;
        }

        /* Subtasks (Basic Styling) */
        .subtask-list { list-style: none; padding-left: 1rem; margin-top: 0.75rem; }
        .subtask-item {
            display: flex; align-items: center; gap: 0.5rem;
            font-size: 0.85rem; padding: 0.25rem 0;
            color: var(--lm-muted-text);
        }
        body.dark-mode .subtask-item { color: var(--dm-muted-text); }
        .subtask-item input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--lm-secondary); }
        body.dark-mode .subtask-item input[type="checkbox"] { accent-color: var(--dm-secondary); }
        .subtask-item.completed label { text-decoration: line-through; opacity: 0.7; }

        /* Task Alerts (Overdue/Upcoming) */
        .task-alert {
            position: absolute; top: 5px; right: 5px;
            font-size: 0.7rem; font-weight: bold; padding: 2px 5px;
            border-radius: 4px; text-transform: uppercase;
        }
        .task-alert.overdue { background-color: var(--lm-alert-expired-bg); color: var(--lm-alert-expired-text); border: 1px solid currentColor; }
        .task-alert.upcoming { background-color: var(--lm-alert-upcoming-bg); color: var(--lm-alert-upcoming-text); border: 1px solid currentColor; }
        body.dark-mode .task-alert.overdue { background-color: var(--dm-alert-expired-bg); color: var(--dm-alert-expired-text); }
        body.dark-mode .task-alert.upcoming { background-color: var(--dm-alert-upcoming-bg); color: var(--dm-alert-upcoming-text); }

        /* Empty State */
        .empty-task-list {
            text-align: center; padding: 3rem 1rem;
            color: var(--lm-muted-text); font-style: italic;
            border: 2px dashed var(--lm-border); border-radius: var(--border-radius);
        }
        body.dark-mode .empty-task-list { color: var(--dm-muted-text); border-color: var(--dm-border); }
        .empty-task-list i { font-size: 2.5rem; display: block; margin-bottom: 1rem; opacity: 0.5; }

        /* --- Graph View Placeholder --- */
        .graph-view-container {
            padding: 2rem; text-align: center; color: var(--lm-muted-text);
            border: 2px dashed var(--lm-border); border-radius: var(--border-radius);
            /* Add transition for view switching */
            transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease;
            opacity: 1;
            transform: translateY(0);
        }
        body.dark-mode .graph-view-container { color: var(--dm-muted-text); border-color: var(--dm-border); }
        .graph-view-container.view-hidden {
            opacity: 0;
            transform: translateY(10px);
            position: absolute; /* Take out of flow during transition */
            pointer-events: none; /* Prevent interaction when hidden */
        }

        /* --- Toast Notifications --- */
        #toast-container {
            position: fixed; bottom: 1.5rem; right: 1.5rem;
            z-index: 1100; display: flex; flex-direction: column;
            gap: 0.5rem; align-items: flex-end;
        }
        .toast {
            background-color: var(--notification-bg); color: var(--notification-text);
            padding: 0.75rem 1.25rem; border-radius: var(--border-radius);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-size: 0.9rem; display: flex; align-items: center; gap: 0.75rem;
            opacity: 0; transform: translateX(100%);
            animation: slideInRight 0.4s ease-out forwards, fadeOutToast 0.4s ease-in 4.5s forwards;
            min-width: 250px; max-width: 350px;
        }
        .toast i { font-size: 1.2rem; }
        .toast.info i { color: var(--lm-info); }
        .toast.success i { color: var(--lm-success); }
        .toast.warning i { color: var(--lm-warning); }
        .toast.error i { color: var(--lm-danger); }
        /* Dark mode doesn't need specific toast styles as bg is dark */

        @keyframes slideInRight { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } }
        @keyframes fadeOutToast { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(5%); } }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            html { font-size: 15px; } /* Slightly smaller base font */
            header { padding: 0.75rem 1rem; }
            main { padding: 1rem; }
            .dashboard-section { grid-template-columns: 1fr; gap: 1rem; } /* Stack cards */
            .todo-header { flex-direction: column; align-items: flex-start; }
            .filters-and-sorting { flex-direction: column; align-items: stretch; }
            .filter-group, .sort-group { min-width: 0; }
            .task-item { flex-direction: column; align-items: stretch; gap: 0.5rem; }
            .task-select-checkbox { position: absolute; top: 1rem; left: 1rem; } /* Position checkbox top-left */
            .task-content { padding-left: 2rem; } /* Indent content */
            .task-main-info { flex-direction: column; align-items: flex-start; gap: 0.25rem; margin-bottom: 0.75rem;}
            .task-actions { flex-direction: row; justify-content: flex-start; margin-top: 0.75rem; }
            .modal-content { padding: 1.5rem; max-width: 95%; }
            .modal-title { font-size: 1.25rem; }
            .header-actions { gap: 0.5rem; }
            .total-timer-display { display: none; } /* Hide total timer on small screens initially */
            .notification-list { width: 280px; }
            #toast-container { bottom: 1rem; right: 1rem; left: 1rem; align-items: stretch; }
            .toast { width: 100%; max-width: none; }
            .action-buttons-container { flex-direction: column; align-items: stretch; } /* Stack action buttons */
            .batch-actions-bar { flex-direction: column; align-items: stretch; text-align: center; }
            .batch-actions-buttons { justify-content: center; margin-top: 0.5rem; }
        }

        @media (max-width: 480px) {
            html { font-size: 14px; }
            .logo span { display: none; } /* Hide text part of logo */
            .btn { padding: 0.6rem 1rem; font-size: 0.85rem; }
            .task-actions .btn { padding: 0.4rem 0.6rem; font-size: 0.75rem; }
            .modal-footer { flex-direction: column; gap: 0.5rem; }
            .modal-footer .btn { width: 100%; }
            .header-actions { /* Show total timer icon-only if needed */ }
        }

        /* Flatpickr Dark Mode */
        .flatpickr-calendar.dark-mode {
            background: var(--dm-component-bg);
            border-color: var(--dm-border);
            box-shadow: 0 3px 13px var(--dm-shadow-color);
        }
        .dark-mode .flatpickr-months .flatpickr-month,
        .dark-mode .flatpickr-current-month .flatpickr-monthDropdown-months,
        .dark-mode .flatpickr-current-month input.cur-year {
            color: var(--dm-text);
            fill: var(--dm-text);
        }
        .dark-mode .flatpickr-months .flatpickr-prev-month,
        .dark-mode .flatpickr-months .flatpickr-next-month {
            fill: var(--dm-muted-text);
        }
        .dark-mode .flatpickr-months .flatpickr-prev-month:hover,
        .dark-mode .flatpickr-months .flatpickr-next-month:hover {
            fill: var(--dm-primary);
        }
        .dark-mode .flatpickr-weekdays, .dark-mode .flatpickr-weekday {
            color: var(--dm-muted-text);
        }
        .dark-mode span.flatpickr-day {
            color: var(--dm-text);
        }
        .dark-mode span.flatpickr-day:hover, .dark-mode span.flatpickr-day.focus {
            background: var(--dm-input-bg);
            border-color: var(--dm-input-bg);
            color: var(--dm-primary);
        }
        .dark-mode span.flatpickr-day.selected,
        .dark-mode span.flatpickr-day.startRange,
        .dark-mode span.flatpickr-day.endRange,
        .dark-mode span.flatpickr-day.selected.inRange,
        .dark-mode span.flatpickr-day.startRange.inRange,
        .dark-mode span.flatpickr-day.endRange.inRange,
        .dark-mode span.flatpickr-day.selected:focus,
        .dark-mode span.flatpickr-day.startRange:focus,
        .dark-mode span.flatpickr-day.endRange:focus,
        .dark-mode span.flatpickr-day.selected:hover,
        .dark-mode span.flatpickr-day.startRange:hover,
        .dark-mode span.flatpickr-day.endRange:hover,
        .dark-mode span.flatpickr-day.selected.prevMonthDay,
        .dark-mode span.flatpickr-day.startRange.prevMonthDay,
        .dark-mode span.flatpickr-day.endRange.prevMonthDay,
        .dark-mode span.flatpickr-day.selected.nextMonthDay,
        .dark-mode span.flatpickr-day.startRange.nextMonthDay,
        .dark-mode span.flatpickr-day.endRange.nextMonthDay {
            background: var(--dm-primary);
            border-color: var(--dm-primary);
            color: #111;
        }
        .dark-mode span.flatpickr-day.flatpickr-disabled,
        .dark-mode span.flatpickr-day.flatpickr-disabled:hover,
        .dark-mode span.flatpickr-day.prevMonthDay,
        .dark-mode span.flatpickr-day.nextMonthDay {
            color: var(--dm-muted-text);
            opacity: 0.6;
        }
        .dark-mode .flatpickr-time {
            border-top-color: var(--dm-border);
        }
        .dark-mode .flatpickr-time input,
        .dark-mode .flatpickr-time .flatpickr-am-pm {
            background: var(--dm-input-bg);
            color: var(--dm-text);
            border-color: var(--dm-border);
        }
        .dark-mode .flatpickr-time .numInputWrapper span.arrowUp:after { border-bottom-color: var(--dm-text); }
        .dark-mode .flatpickr-time .numInputWrapper span.arrowDown:after { border-top-color: var(--dm-text); }

    </style>
</head>
<body class="login-view">

    <div class="login-container" id="loginContainer">
        <h1 class="login-title"><i class="fas fa-check-double"></i> TaskMaster Pro</h1>
        <form id="loginForm">
            <div class="input-group">
                <label for="username">Username</label>
                <input type="text" id="username" class="input-field" placeholder="Enter your username" required>
            </div>
            <div class="input-group">
                <label for="password">Password</label>
                <input type="password" id="password" class="input-field" placeholder="Enter your password" required>
            </div>
            <button type="submit" class="btn btn-primary btn-block">Login</button>
        </form>
        <p class="register-link">Don't have an account? <a id="registerLink">Register here</a></p> </div>

    <div class="app-container" id="appContainer">
        <header>
            <a href="#" class="logo" id="refreshLogo"><i class="fas fa-check-double"></i> <span>TaskMaster Pro</span></a>
            <div class="header-actions">
                <div class="total-timer-display" id="totalTimerDisplay">
                    <i class="fas fa-stopwatch"></i>
                    <span>Total Today:</span>
                    <span id="total-timer-value">00:00:00</span>
                </div>
                <div class="notification-bell">
                    <button id="notificationBtn" class="btn-icon" aria-label="Notifications">
                        <i class="fas fa-bell"></i>
                        <span id="notification-count" class="hidden">0</span>
                    </button>
                    <div id="notificationList" class="notification-list">
                        <div class="notification-empty">No new notifications</div>
                    </div>
                </div>
                 <button id="themeToggleBtn" class="theme-toggle btn-icon" aria-label="Toggle Theme">
                    <i class="fas fa-moon"></i> </button>
                <button id="logoutBtn" class="btn btn-danger btn-icon" aria-label="Logout">
                    <i class="fas fa-sign-out-alt"></i>
                    <span class="logout-text">Logout</span> </button>
                <style> @media (max-width: 768px) { .logout-text { display: none; } } </style>
            </div>
        </header>

        <main>
            <section class="dashboard-section">
                <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-list-check"></i></div>
                    <div id="totalTasksStat" class="stat-value">0</div>
                    <div class="stat-label">Total Tasks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-hourglass-half" style="color: var(--lm-warning);"></i></div>
                    <div id="pendingTasksStat" class="stat-value">0</div>
                    <div class="stat-label">Pending</div>
                </div>
                 <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-calendar-day" style="color: var(--lm-info);"></i></div>
                    <div id="dueTodayStat" class="stat-value">0</div>
                    <div class="stat-label">Due Today</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-check-circle" style="color: var(--lm-success);"></i></div>
                    <div id="completedTasksStat" class="stat-value">0</div>
                    <div class="stat-label">Completed</div>
                </div>
            </section>

            <section class="todo-section">
                <div class="todo-header">
                    <h2 class="todo-title">My Tasks</h2>
                    <div class="view-switcher">
                        <button id="listViewBtn" class="btn btn-light active" aria-pressed="true"><i class="fas fa-list"></i> List</button>
                        <button id="graphViewBtn" class="btn btn-light" aria-pressed="false"><i class="fas fa-chart-pie"></i> Graph</button>
                    </div>
                </div>

                <div class="action-buttons-container">
                     <button id="addTaskBtn" class="btn btn-primary"><i class="fas fa-plus"></i> Add Task</button>
                     <button id="importBtn" class="btn btn-secondary"><i class="fas fa-file-import"></i> Import</button>
                     <input type="file" id="importFile" accept=".json" class="visually-hidden">
                     <button id="exportBtn" class="btn btn-secondary"><i class="fas fa-file-export"></i> Export</button>
                </div>

                <div class="filters-and-sorting">
                    <div class="filter-group">
                        <label for="filterPriority">Priority</label>
                        <select id="filterPriority" class="filter-select">
                            <option value="all">All Priorities</option>
                            <option value="high">High</option>
                            <option value="medium">Medium</option>
                            <option value="low">Low</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="filterCategory">Category</label>
                        <select id="filterCategory" class="filter-select">
                            <option value="all">All Categories</option>
                            </select>
                    </div>
                    <div class="filter-group">
                        <label for="filterDueDate">Due Date</label>
                        <select id="filterDueDate" class="filter-select">
                            <option value="all">All Dates</option>
                            <option value="overdue">Overdue</option>
                            <option value="today">Today</option>
                            <option value="tomorrow">Tomorrow</option>
                            <option value="this_week">This Week</option>
                            <option value="no_due_date">No Due Date</option>
                        </select>
                    </div>
                     <div class="filter-group">
                        <label for="filterStatus">Status</label>
                        <select id="filterStatus" class="filter-select">
                            <option value="all">All Status</option>
                            <option value="pending">Pending</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    <div class="sort-group">
                         <label for="sortTasks">Sort By</label>
                         <select id="sortTasks" class="sort-select">
                             <option value="default">Default</option>
                             <option value="dueDateAsc">Due Date (Oldest First)</option>
                             <option value="dueDateDesc">Due Date (Newest First)</option>
                             <option value="priorityDesc">Priority (High First)</option>
                             <option value="priorityAsc">Priority (Low First)</option>
                             <option value="titleAsc">Title (A-Z)</option>
                         </select>
                    </div>
                    <button id="resetFiltersBtn" class="btn btn-secondary"><i class="fas fa-undo"></i> Reset</button>
                </div>

                 <div id="batchActionsBar" class="batch-actions-bar">
                    <span id="selectedCount">0 tasks selected</span>
                    <div class="batch-actions-buttons">
                        <button id="batchCompleteBtn" class="btn btn-success btn-sm"><i class="fas fa-check-circle"></i> Mark Complete</button>
                        <button id="batchDeleteBtn" class="btn btn-danger btn-sm"><i class="fas fa-trash-alt"></i> Delete</button>
                    </div>
                </div>

                <div id="taskListContainer" class="task-list-container">
                    <ul id="taskList" class="task-list">
                        </ul>
                     <div id="emptyTaskListMessage" class="empty-task-list hidden">
                         <i class="fas fa-folder-open"></i>
                         <p>No tasks found. Add a new task to get started!</p>
                     </div>
                </div>

                 <div id="graphViewContainer" class="graph-view-container view-hidden">
                     <i class="fas fa-chart-pie" style="font-size: 3rem; opacity: 0.5; margin-bottom: 1rem;"></i>
                     <p>Graph view is under construction. Task statistics will be displayed here.</p>
                     <p><small>(Requires a charting library like Chart.js)</small></p>
                </div>
            </section>

        </main>
    </div>

    <div id="taskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle" class="modal-title">Add New Task</h3>
                <button class="modal-close-btn" data-dismiss="modal" aria-label="Close">&times;</button>
            </div>
            <form id="taskForm">
                <input type="hidden" id="taskId">
                <div class="modal-body">
                    <div class="input-group">
                        <label for="taskTitle">Title</label>
                        <input type="text" id="taskTitle" class="input-field" placeholder="e.g., Buy groceries" required>
                    </div>
                    <div class="input-group">
                        <label for="taskDescription">Description (Optional)</label>
                        <textarea id="taskDescription" class="input-field" placeholder="Add more details..."></textarea>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 1.25rem;">
                        <div class="input-group" style="margin-bottom: 0;">
                            <label for="taskPriority">Priority</label>
                            <select id="taskPriority" class="filter-select">
                                <option value="medium">Medium</option>
                                <option value="high">High</option>
                                <option value="low">Low</option>
                            </select>
                        </div>
                        <div class="input-group" style="margin-bottom: 0;">
                            <label for="taskCategory">Category</label>
                            <input type="text" id="taskCategory" class="input-field" placeholder="e.g., Work, Personal">
                            </div>
                    </div>
                     <div class="input-group">
                        <label for="taskDueDate">Due Date (Optional)</label>
                        <input type="text" id="taskDueDate" class="input-field filter-date" placeholder="Select date & time">
                    </div>

                    <div class="input-group">
                        <label for="taskRecurrence">Recurrence</label>
                        <select id="taskRecurrence" class="filter-select">
                            <option value="none">None</option>
                            <option value="daily">Daily</option>
                            <option value="weekly">Weekly</option>
                            <option value="monthly">Monthly</option>
                            </select>
                         <small class="text-muted" style="font-size: 0.8rem; margin-top: 0.25rem;">(Full recurrence logic pending implementation)</small>
                    </div>

                     <div class="input-group">
                         <label>Subtasks</label>
                         <div id="subtaskListModal" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--lm-border); border-radius: var(--border-radius); padding: 0.5rem;">
                             </div>
                         <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                             <input type="text" id="newSubtaskInput" class="input-field" placeholder="Add a subtask..." style="flex-grow: 1;">
                             <button type="button" id="addSubtaskBtnModal" class="btn btn-secondary btn-sm"><i class="fas fa-plus"></i> Add</button>
                         </div>
                          <small class="text-muted" style="font-size: 0.8rem; margin-top: 0.25rem;">(Subtask functionality pending full implementation)</small>
                     </div>

                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
                    <button type="submit" id="saveTaskBtn" class="btn btn-primary">Save Task</button>
                </div>
            </form>
        </div>
    </div>

    <div id="confirmationModal" class="modal">
        <div class="modal-content"> <div class="modal-header">
                <h3 id="confirmationTitle" class="modal-title">Confirm Action</h3>
                 <button class="modal-close-btn" data-dismiss="modal" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <p id="confirmationMessage">Are you sure?</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
                <button type="button" id="confirmActionBtn" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <div id="registrationModal" class="modal">
        <div class="modal-content"> <div class="modal-header">
                <h3 class="modal-title">Register New Account</h3>
                <button class="modal-close-btn" data-dismiss="modal" aria-label="Close">&times;</button>
            </div>
            <form id="registrationForm">
                <div class="modal-body">
                    <div class="input-group">
                        <label for="regUsername">Username</label>
                        <input type="text" id="regUsername" class="input-field" placeholder="Choose a username" required>
                    </div>
                    <div class="input-group">
                        <label for="regPassword">Password</label>
                        <input type="password" id="regPassword" class="input-field" placeholder="Create a password" required>
                    </div>
                     <div class="input-group">
                        <label for="regConfirmPassword">Confirm Password</label>
                        <input type="password" id="regConfirmPassword" class="input-field" placeholder="Confirm your password" required>
                    </div>
                    <p style="font-size: 0.8rem; color: var(--lm-muted-text);">Note: This is a simulation. Passwords are not stored securely.</p>
                    <body.dark-mode p style="color: var(--dm-muted-text);"></body.dark-mode>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
                    <button type="submit" class="btn btn-primary">Register</button>
                </div>
            </form>
        </div>
    </div>


    <div id="toast-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const body = document.body; // Reference to body element
            const loginContainer = document.getElementById('loginContainer');
            const loginForm = document.getElementById('loginForm');
            const loginUsernameInput = document.getElementById('username'); // Added for login check
            const loginPasswordInput = document.getElementById('password'); // Added for login check
            const registerLink = document.getElementById('registerLink');
            const appContainer = document.getElementById('appContainer');
            const refreshLogo = document.getElementById('refreshLogo');
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            const logoutBtn = document.getElementById('logoutBtn');
            const notificationBtn = document.getElementById('notificationBtn');
            const notificationCount = document.getElementById('notification-count');
            const notificationList = document.getElementById('notificationList');
            const totalTimerDisplay = document.getElementById('totalTimerDisplay');
            const totalTimerValue = document.getElementById('total-timer-value');

            // Dashboard Stats
            const totalTasksStat = document.getElementById('totalTasksStat');
            const pendingTasksStat = document.getElementById('pendingTasksStat');
            const dueTodayStat = document.getElementById('dueTodayStat');
            const completedTasksStat = document.getElementById('completedTasksStat');

            // ToDo Section Elements
            const addTaskBtn = document.getElementById('addTaskBtn');
            const importBtn = document.getElementById('importBtn');
            const importFile = document.getElementById('importFile');
            const exportBtn = document.getElementById('exportBtn');
            const filterPriority = document.getElementById('filterPriority');
            const filterCategory = document.getElementById('filterCategory');
            const filterDueDate = document.getElementById('filterDueDate');
            const filterStatus = document.getElementById('filterStatus');
            const sortTasks = document.getElementById('sortTasks');
            const resetFiltersBtn = document.getElementById('resetFiltersBtn');
            const taskList = document.getElementById('taskList');
            const emptyTaskListMessage = document.getElementById('emptyTaskListMessage');
            const batchActionsBar = document.getElementById('batchActionsBar');
            const selectedCount = document.getElementById('selectedCount');
            const batchCompleteBtn = document.getElementById('batchCompleteBtn');
            const batchDeleteBtn = document.getElementById('batchDeleteBtn');
            const listViewBtn = document.getElementById('listViewBtn');
            const graphViewBtn = document.getElementById('graphViewBtn');
            const taskListContainer = document.getElementById('taskListContainer');
            const graphViewContainer = document.getElementById('graphViewContainer');

            // Task Modal Elements
            const taskModal = document.getElementById('taskModal');
            const modalTitle = document.getElementById('modalTitle');
            const taskForm = document.getElementById('taskForm');
            const taskIdInput = document.getElementById('taskId');
            const taskTitleInput = document.getElementById('taskTitle');
            const taskDescriptionInput = document.getElementById('taskDescription');
            const taskPriorityInput = document.getElementById('taskPriority');
            const taskCategoryInput = document.getElementById('taskCategory');
            const taskDueDateInput = document.getElementById('taskDueDate');
            const taskRecurrenceInput = document.getElementById('taskRecurrence');
            const subtaskListModal = document.getElementById('subtaskListModal');
            const newSubtaskInput = document.getElementById('newSubtaskInput');
            const addSubtaskBtnModal = document.getElementById('addSubtaskBtnModal');
            const saveTaskBtn = document.getElementById('saveTaskBtn');

            // Confirmation Modal Elements
            const confirmationModal = document.getElementById('confirmationModal');
            const confirmationTitle = document.getElementById('confirmationTitle');
            const confirmationMessage = document.getElementById('confirmationMessage');
            const confirmActionBtn = document.getElementById('confirmActionBtn');

            // Registration Modal Elements
            const registrationModal = document.getElementById('registrationModal');
            const registrationForm = document.getElementById('registrationForm');
            const regUsernameInput = document.getElementById('regUsername');
            const regPasswordInput = document.getElementById('regPassword');
            const regConfirmPasswordInput = document.getElementById('regConfirmPassword');


            const toastContainer = document.getElementById('toast-container');

            // --- State Variables ---
            let tasks = [];
            let categories = new Set();
            let selectedTaskIds = new Set();
            let currentEditTaskId = null;
            let currentView = 'list'; // 'list' or 'graph'
            let taskTimers = {}; // { taskId: { intervalId: null, startTime: null } }
            let totalElapsedToday = 0; // In seconds
            let totalTimerInterval = null;
            let lastMidnightCheck = new Date().setHours(0, 0, 0, 0); // For daily reset

            // --- Initialization ---
            initializeDatePickers();
            checkLoginStatus(); // Check if already logged in
            // loadState(), renderAll(), etc. are called by checkLoginStatus if logged in

            setInterval(checkDueDates, 60 * 1000); // Check due dates every minute

            // --- Core Functions ---

             /**
             * Checks login status and sets up the correct view (Login or App).
             */
            function checkLoginStatus() {
                const loggedInUser = localStorage.getItem('loggedInUser');
                if (loggedInUser) {
                    // User is logged in, show app view
                    body.classList.remove('login-view');
                    body.classList.add('app-view');
                    loginContainer.style.display = 'none';
                    appContainer.style.display = 'block';
                    loadState(); // Load data for the logged-in user
                    updateTheme(localStorage.getItem('theme') || 'light');
                    renderAll();
                    checkDueDates();
                    startTotalTimer();
                    addNotification(`Welcome back, ${loggedInUser}!`, 'info', 3000);
                } else {
                    // User is not logged in, show login view
                    body.classList.remove('app-view');
                    body.classList.add('login-view');
                    appContainer.style.display = 'none';
                    loginContainer.style.display = 'block';
                     updateTheme(localStorage.getItem('theme') || 'light'); // Apply theme even on login page
                }
            }


            /**
             * Loads state from localStorage (tasks, theme, categories, timers).
             */
            function loadState() {
                // Prefix storage keys with username for multi-user simulation
                const loggedInUser = localStorage.getItem('loggedInUser');
                if (!loggedInUser) return; // Should not happen if called correctly

                const userPrefix = `user_${loggedInUser}_`;

                const storedTasks = localStorage.getItem(userPrefix + 'tasks');
                const storedCategories = localStorage.getItem(userPrefix + 'categories');
                const storedTimers = localStorage.getItem(userPrefix + 'taskTimers');
                const storedTotalElapsed = localStorage.getItem(userPrefix + 'totalElapsedToday');
                const storedLastReset = localStorage.getItem(userPrefix + 'lastMidnightCheck');
                // Theme is global, not user-specific in this setup
                const storedTheme = localStorage.getItem('theme');


                tasks = storedTasks ? JSON.parse(storedTasks) : [];
                categories = storedCategories ? new Set(JSON.parse(storedCategories)) : new Set();
                totalElapsedToday = storedTotalElapsed ? parseInt(storedTotalElapsed, 10) : 0;
                lastMidnightCheck = storedLastReset ? parseInt(storedLastReset, 10) : new Date().setHours(0, 0, 0, 0);

                // Check for daily reset
                const todayMidnight = new Date().setHours(0, 0, 0, 0);
                if (todayMidnight > lastMidnightCheck) {
                    console.log("Performing daily timer reset.");
                    totalElapsedToday = 0;
                    lastMidnightCheck = todayMidnight;
                    // Don't save here, saveState will handle it later
                }


                // Initialize categories from loaded tasks if storage is empty
                if (categories.size === 0 && tasks.length > 0) {
                     tasks.forEach(task => {
                        if (task.category) categories.add(task.category);
                     });
                }

                // Restore timers
                taskTimers = {}; // Reset local timer state
                const savedTimers = storedTimers ? JSON.parse(storedTimers) : {};
                tasks.forEach(task => {
                    if (!task.elapsedTime) task.elapsedTime = 0; // Ensure elapsedTime exists

                    const savedTimer = savedTimers[task.id];
                    if (savedTimer) {
                        task.elapsedTime = savedTimer.elapsedTime || 0;
                        // If timer was running when page closed/refreshed, resume it
                        if (savedTimer.timerStartTime) {
                            const now = Date.now();
                            // Calculate time missed since timer was last known to be running
                            const elapsedSinceStart = Math.floor((now - savedTimer.timerStartTime) / 1000);
                             // Add the missed time to the task's elapsed time BEFORE starting the interval
                            task.elapsedTime += elapsedSinceStart;
                            // Start the timer interval again, it will use the updated task.elapsedTime
                            startTimer(task.id, true, savedTimer.timerStartTime); // Pass original start time
                        }
                    }
                });

                 // Add sample data if no tasks exist FOR THIS USER
                if (tasks.length === 0 && !storedTasks) { // Only add samples if no tasks were ever stored for this user
                    addSampleTasks();
                }

                updateTheme(storedTheme || 'light');
            }

            /**
             * Saves the current state to localStorage.
             */
            function saveState() {
                 const loggedInUser = localStorage.getItem('loggedInUser');
                 if (!loggedInUser) return; // Don't save if not logged in

                 const userPrefix = `user_${loggedInUser}_`;

                try {
                    localStorage.setItem(userPrefix + 'tasks', JSON.stringify(tasks));
                    localStorage.setItem(userPrefix + 'categories', JSON.stringify(Array.from(categories)));

                    // Save timer state accurately
                    const timersToSave = {};
                    tasks.forEach(task => {
                        let currentElapsedTime = task.elapsedTime || 0;
                        let currentStartTime = null; // Assume paused unless proven otherwise

                        // Check if there's an active timer interval for this task
                        if (taskTimers[task.id] && taskTimers[task.id].intervalId && taskTimers[task.id].startTime) {
                             // Timer is running, calculate elapsed time up to now
                            const now = Date.now();
                            // Time elapsed *during this active interval*
                            const elapsedInInterval = Math.floor((now - taskTimers[task.id].startTime) / 1000);
                            // Total time is the base time (task.elapsedTime) + time in this interval
                            // IMPORTANT: task.elapsedTime should hold the time *before* this interval started
                            // Let's recalculate based on the initial start time if available
                            currentElapsedTime = task.elapsedTime + elapsedInInterval; // Add interval time to base time
                            currentStartTime = taskTimers[task.id].startTime; // Store the actual start time of this interval
                         } else {
                            // Timer is paused, just save the last known total elapsed time
                            currentElapsedTime = task.elapsedTime || 0;
                            currentStartTime = null;
                         }

                        timersToSave[task.id] = {
                            elapsedTime: currentElapsedTime,
                            timerStartTime: currentStartTime // null if paused, timestamp if running
                        };
                    });
                    localStorage.setItem(userPrefix + 'taskTimers', JSON.stringify(timersToSave));
                    localStorage.setItem(userPrefix + 'totalElapsedToday', totalElapsedToday.toString());
                    localStorage.setItem(userPrefix + 'lastMidnightCheck', lastMidnightCheck.toString());
                    // Save theme globally
                    localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');


                } catch (error) {
                    console.error("Error saving state to localStorage:", error);
                    addNotification("Could not save changes. Storage might be full.", "error");
                }
            }

             /**
             * Adds sample tasks for demonstration (called only if user has no tasks).
             */
            function addSampleTasks() {
                const now = new Date();
                const tomorrow = new Date(now); tomorrow.setDate(now.getDate() + 1);
                const nextWeek = new Date(now); nextWeek.setDate(now.getDate() + 7);
                const yesterday = new Date(now); yesterday.setDate(now.getDate() - 1);

                // Reset tasks array before adding samples
                tasks = [
                    { id: generateId(), title: "Finalize Project Proposal", description: "Review feedback and submit", priority: "high", category: "Work", dueDate: formatDateTime(now), completed: false, createdAt: Date.now() - 86400000, elapsedTime: 3665 }, // Due today, 1h 1m 5s elapsed
                    { id: generateId(), title: "Schedule Team Meeting", description: "", priority: "medium", category: "Work", dueDate: formatDateTime(tomorrow), completed: false, createdAt: Date.now() - 172800000, elapsedTime: 0 }, // Due tomorrow
                    { id: generateId(), title: "Grocery Shopping", description: "Milk, Eggs, Bread", priority: "medium", category: "Personal", dueDate: null, completed: false, createdAt: Date.now() - 259200000, elapsedTime: 1230 }, // No due date, 20m 30s elapsed
                    { id: generateId(), title: "Pay Utility Bills", description: "Electricity and Water", priority: "high", category: "Finance", dueDate: formatDateTime(yesterday), completed: false, createdAt: Date.now() - 604800000, elapsedTime: 0 }, // Overdue
                    { id: generateId(), title: "Plan Weekend Trip", description: "Research destinations", priority: "low", category: "Personal", dueDate: formatDateTime(nextWeek), completed: false, createdAt: Date.now(), elapsedTime: 0 }, // Due next week
                    { id: generateId(), title: "Read Chapter 5", description: "Book club reading", priority: "low", category: "Leisure", dueDate: null, completed: true, createdAt: Date.now() - 345600000, completedAt: Date.now() - 86400000, elapsedTime: 7200 }, // Completed yesterday, 2h elapsed
                ];
                // Reset categories and repopulate from sample tasks
                categories = new Set();
                tasks.forEach(task => {
                    if (task.category) categories.add(task.category);
                });
                saveState(); // Save sample tasks for the new user
            }

            /**
             * Renders everything: tasks, stats, filters, etc.
             */
            function renderAll() {
                renderTasks();
                updateStats();
                populateCategoryFilter();
                updateBatchActionBar();
                checkEmptyState();
                // Ensure view containers visibility matches currentView
                taskListContainer.classList.toggle('view-hidden', currentView !== 'list');
                graphViewContainer.classList.toggle('view-hidden', currentView !== 'graph');

            }

            /**
             * Renders the task list based on current filters and sorting.
             */
            function renderTasks() {
                const filteredTasks = filterAndSortTasks();
                taskList.innerHTML = ''; // Clear existing list

                if (filteredTasks.length === 0 && tasks.length > 0) { // Check if filters result in empty, but tasks exist
                     taskList.innerHTML = '<li class="empty-task-list" style="border: none; padding: 1rem;"><p>No tasks match the current filters.</p></li>';
                     emptyTaskListMessage.classList.add('hidden'); // Hide the main empty message
                     return;
                 } else if (tasks.length === 0) {
                     checkEmptyState(); // Show the main empty message if no tasks at all
                     return;
                 }


                filteredTasks.forEach(task => {
                    const taskElement = createTaskElement(task);
                    taskList.appendChild(taskElement);

                     // Ensure timer display is correct based on loaded state
                     updateTimerDisplay(task.id, task.elapsedTime || 0);
                     updateTimerButton(task.id, taskTimers[task.id]?.intervalId != null);

                     // Re-start interval if it should be running (loadState handles initial resume)
                     // This ensures intervals are running after filtering/re-rendering
                     if (taskTimers[task.id] && taskTimers[task.id].startTime && !taskTimers[task.id].intervalId) {
                         // This scenario should ideally be handled by loadState or pauseTimer correctly setting intervalId to null
                         // If we reach here, it means the timer *should* be running but the interval isn't set. Resume it.
                         console.warn(`Resuming interval for task ${task.id} during render.`);
                         startTimer(task.id, true, taskTimers[task.id].startTime);
                     }
                });
                checkEmptyState(); // Hide empty message if tasks exist
            }

            /**
             * Creates the HTML element for a single task.
             * @param {object} task - The task object.
             * @returns {HTMLElement} - The list item element.
             */
            function createTaskElement(task) {
                const li = document.createElement('li');
                li.className = `task-item ${task.completed ? 'completed' : ''} ${selectedTaskIds.has(task.id) ? 'selected' : ''}`;
                li.dataset.taskId = task.id;

                // Determine due date status
                let dueDateStatus = '';
                let dueDateText = 'No due date';
                let alertHtml = '';
                if (task.dueDate) {
                    try {
                        const dueDate = new Date(task.dueDate);
                        const today = new Date();
                        today.setHours(0, 0, 0, 0); // Start of today
                        const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate()); // Date part only

                        const tomorrow = new Date(today); tomorrow.setDate(today.getDate() + 1);
                        const threeDaysFromNow = new Date(today); threeDaysFromNow.setDate(today.getDate() + 3);

                        dueDateText = formatFriendlyDate(dueDate); // Use original date for display

                        if (!task.completed && dueDateOnly < today) {
                            dueDateStatus = 'overdue';
                            alertHtml = `<span class="task-alert overdue">Overdue</span>`;
                        } else if (dueDateOnly.getTime() === today.getTime()) {
                            dueDateStatus = 'today';
                            alertHtml = `<span class="task-alert upcoming">Due Today</span>`;
                        } else if (!task.completed && dueDateOnly > today && dueDateOnly < threeDaysFromNow) {
                            // Optional: Add upcoming alert visually if needed
                            // alertHtml = `<span class="task-alert upcoming">Upcoming</span>`;
                        }
                    } catch (e) {
                        console.error("Error parsing due date:", task.dueDate, e);
                        dueDateText = "Invalid Date";
                    }
                }

                // Timer display
                const elapsedSeconds = task.elapsedTime || 0;
                const formattedTime = formatTime(elapsedSeconds);
                const isTimerActive = taskTimers[task.id] && taskTimers[task.id].intervalId;

                li.innerHTML = `
                    <input type="checkbox" class="task-select-checkbox" aria-label="Select task ${task.title}" ${selectedTaskIds.has(task.id) ? 'checked' : ''}>
                    <div class="task-content">
                        <div class="task-main-info">
                            <span class="task-title">${escapeHTML(task.title)}</span>
                            <span class="task-due-date ${dueDateStatus}">${dueDateText}</span>
                        </div>
                        ${task.description ? `<p class="task-description">${escapeHTML(task.description)}</p>` : ''}
                        <div class="task-meta">
                            ${task.priority ? `<span class="task-priority ${task.priority.toLowerCase()}"><i class="fas fa-flag"></i> ${escapeHTML(task.priority)}</span>` : ''}
                            ${task.category ? `<span class="task-category"><i class="fas fa-tag"></i> ${escapeHTML(task.category)}</span>` : ''}
                            ${task.recurrence && task.recurrence !== 'none' ? `<span class="task-recurrence"><i class="fas fa-redo"></i> ${escapeHTML(task.recurrence)}</span>` : ''}
                        </div>
                         <div class="task-timer">
                            <button class="btn btn-icon btn-sm timer-toggle-btn ${isTimerActive ? 'btn-warning' : 'btn-success'}" data-action="toggle-timer" aria-label="${isTimerActive ? 'Pause timer' : 'Start timer'}">
                                <i class="fas ${isTimerActive ? 'fa-pause' : 'fa-play'}"></i>
                            </button>
                            <span class="timer-status ${isTimerActive ? 'active' : ''}" id="timer-${task.id}">${formattedTime}</span>
                        </div>
                        </div>
                    <div class="task-actions">
                        <button class="btn btn-outline-primary btn-icon btn-sm" data-action="edit" aria-label="Edit task"><i class="fas fa-edit"></i></button>
                        <button class="btn ${task.completed ? 'btn-secondary' : 'btn-success'} btn-icon btn-sm" data-action="toggle-complete" aria-label="${task.completed ? 'Mark as pending' : 'Mark as complete'}">
                            <i class="fas ${task.completed ? 'fa-undo' : 'fa-check'}"></i>
                        </button>
                        <button class="btn btn-outline-danger btn-icon btn-sm" data-action="delete" aria-label="Delete task"><i class="fas fa-trash-alt"></i></button>
                    </div>
                    ${alertHtml}
                `;

                // --- Event Listeners for Task Item ---
                const checkbox = li.querySelector('.task-select-checkbox');
                checkbox.addEventListener('change', (e) => {
                    handleTaskSelect(task.id, e.target.checked);
                });

                // Click on task item (excluding buttons/checkbox) to potentially open details/edit
                li.addEventListener('click', (e) => {
                    // Prevent triggering edit if clicking on checkbox, buttons, or timer
                    if (e.target.closest('button, input[type="checkbox"], .task-timer')) {
                        return;
                    }
                    openTaskModal(task.id); // Open modal for editing
                });


                // Action buttons within the task item
                li.querySelector('[data-action="edit"]').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent li click listener
                    openTaskModal(task.id);
                });
                li.querySelector('[data-action="toggle-complete"]').addEventListener('click', (e) => {
                     e.stopPropagation();
                    toggleTaskComplete(task.id);
                });
                 li.querySelector('[data-action="delete"]').addEventListener('click', (e) => {
                     e.stopPropagation();
                    deleteTaskWithConfirmation(task.id);
                 });
                 li.querySelector('[data-action="toggle-timer"]').addEventListener('click', (e) => {
                     e.stopPropagation();
                     toggleTimer(task.id);
                 });


                return li;
            }

            /**
             * Filters and sorts tasks based on selected criteria.
             * @returns {Array} - The filtered and sorted array of tasks.
             */
            function filterAndSortTasks() {
                let filtered = [...tasks];

                // Filtering
                const priorityFilter = filterPriority.value;
                const categoryFilter = filterCategory.value;
                const dueDateFilter = filterDueDate.value;
                const statusFilter = filterStatus.value;

                if (priorityFilter !== 'all') {
                    filtered = filtered.filter(task => task.priority === priorityFilter);
                }
                if (categoryFilter !== 'all') {
                    filtered = filtered.filter(task => task.category === categoryFilter);
                }
                 if (statusFilter !== 'all') {
                    const isCompleted = statusFilter === 'completed';
                    filtered = filtered.filter(task => task.completed === isCompleted);
                }
                if (dueDateFilter !== 'all') {
                    const today = new Date(); today.setHours(0, 0, 0, 0);
                    const tomorrow = new Date(today); tomorrow.setDate(today.getDate() + 1);
                    const endOfWeek = new Date(today); endOfWeek.setDate(today.getDate() + (7 - today.getDay())); // End of current week (Sunday)

                    filtered = filtered.filter(task => {
                        if (!task.dueDate) return dueDateFilter === 'no_due_date';
                        try {
                            const dueDate = new Date(task.dueDate);
                            const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate()); // Date part only

                            switch (dueDateFilter) {
                                case 'overdue': return !task.completed && dueDateOnly < today;
                                case 'today': return dueDateOnly.getTime() === today.getTime();
                                case 'tomorrow': return dueDateOnly.getTime() === tomorrow.getTime();
                                case 'this_week': return dueDateOnly >= today && dueDateOnly <= endOfWeek;
                                case 'no_due_date': return false; // Already handled above
                                default: return true;
                            }
                        } catch (e) { return false; } // Invalid date fails filter
                    });
                }

                // Sorting
                const sortBy = sortTasks.value;
                const priorityOrder = { high: 3, medium: 2, low: 1, default: 0 };

                filtered.sort((a, b) => {
                    switch (sortBy) {
                        case 'dueDateAsc':
                            const dateA = a.dueDate ? new Date(a.dueDate).getTime() : Infinity;
                            const dateB = b.dueDate ? new Date(b.dueDate).getTime() : Infinity;
                            return (isNaN(dateA) ? Infinity : dateA) - (isNaN(dateB) ? Infinity : dateB);
                        case 'dueDateDesc':
                             const dateADesc = a.dueDate ? new Date(a.dueDate).getTime() : -Infinity;
                             const dateBDesc = b.dueDate ? new Date(b.dueDate).getTime() : -Infinity;
                            return (isNaN(dateBDesc) ? -Infinity : dateBDesc) - (isNaN(dateADesc) ? -Infinity : dateADesc);
                        case 'priorityDesc':
                            return (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
                        case 'priorityAsc':
                             return (priorityOrder[a.priority] || 0) - (priorityOrder[b.priority] || 0);
                        case 'titleAsc':
                            return a.title.localeCompare(b.title);
                        case 'default':
                        default:
                            // Default sort: Pending first, then by due date (soonest first), then creation date
                            if (a.completed !== b.completed) return a.completed ? 1 : -1; // Pending before completed
                            const dueDateA = a.dueDate ? new Date(a.dueDate).getTime() : Infinity;
                            const dueDateB = b.dueDate ? new Date(b.dueDate).getTime() : Infinity;
                            const validDateA = isNaN(dueDateA) ? Infinity : dueDateA;
                            const validDateB = isNaN(dueDateB) ? Infinity : dueDateB;
                            if (validDateA !== validDateB) return validDateA - validDateB;
                            return (b.createdAt || 0) - (a.createdAt || 0); // Newest created first if due dates same
                    }
                });

                return filtered;
            }

            /**
             * Updates the dashboard statistics.
             */
            function updateStats() {
                const total = tasks.length;
                const completed = tasks.filter(task => task.completed).length;
                const pending = total - completed;
                const today = new Date(); today.setHours(0, 0, 0, 0);
                const dueToday = tasks.filter(task => {
                    if (!task.dueDate || task.completed) return false;
                    try {
                        const dueDate = new Date(task.dueDate);
                        const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate());
                        return dueDateOnly.getTime() === today.getTime();
                    } catch (e) { return false; }
                }).length;

                totalTasksStat.textContent = total;
                pendingTasksStat.textContent = pending;
                completedTasksStat.textContent = completed;
                dueTodayStat.textContent = dueToday;
            }

             /**
             * Populates the category filter dropdown.
             */
            function populateCategoryFilter() {
                const currentCategoryValue = filterCategory.value; // Preserve selection
                filterCategory.innerHTML = '<option value="all">All Categories</option>'; // Reset
                // Sort categories alphabetically for better UI
                const sortedCategories = Array.from(categories).sort((a, b) => a.localeCompare(b));
                sortedCategories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = cat;
                    filterCategory.appendChild(option);
                });
                 // Try to restore selection, default to 'all' if category was deleted
                if (categories.has(currentCategoryValue)) {
                    filterCategory.value = currentCategoryValue;
                } else {
                    filterCategory.value = 'all';
                }
            }

            /**
             * Checks if the task list is empty and shows/hides the message.
             */
            function checkEmptyState() {
                 // Only show the main empty message if there are absolutely no tasks stored
                emptyTaskListMessage.classList.toggle('hidden', tasks.length > 0);
            }

            /**
             * Opens the task modal for adding or editing.
             * @param {string|null} taskId - The ID of the task to edit, or null to add.
             */
            function openTaskModal(taskId = null) {
                taskForm.reset(); // Clear form
                subtaskListModal.innerHTML = ''; // Clear subtasks
                currentEditTaskId = taskId;

                if (taskId) {
                    const task = tasks.find(t => t.id === taskId);
                    if (!task) return;
                    modalTitle.textContent = 'Edit Task';
                    taskIdInput.value = task.id;
                    taskTitleInput.value = task.title;
                    taskDescriptionInput.value = task.description || '';
                    taskPriorityInput.value = task.priority || 'medium';
                    taskCategoryInput.value = task.category || '';
                    taskDueDateInput.value = task.dueDate || ''; // Flatpickr expects YYYY-MM-DD HH:MM
                    taskRecurrenceInput.value = task.recurrence || 'none';
                    // Populate subtasks if they exist (basic)
                    // task.subtasks?.forEach(sub => addSubtaskElement(sub.text, sub.completed));
                    flatpickrInstance.setDate(task.dueDate ? task.dueDate : null, false); // Update date picker without triggering change event
                } else {
                    modalTitle.textContent = 'Add New Task';
                    taskIdInput.value = '';
                    flatpickrInstance.clear(); // Clear date picker for new task
                }

                taskModal.classList.add('show');
                taskTitleInput.focus(); // Focus title field when opening
            }

            /**
             * Closes the currently open modal.
             * @param {HTMLElement} modalElement - The modal element to close.
             */
            function closeModal(modalElement) {
                 if (modalElement && modalElement.classList.contains('show')) {
                    modalElement.classList.remove('show');
                    // Optional: Add fade-out animation class
                    // modalElement.classList.add('fade-out');
                    // setTimeout(() => {
                    //    modalElement.classList.remove('show', 'fade-out');
                    // }, 300); // Match animation duration
                 }
            }

            /**
             * Handles saving or updating a task from the modal form.
             * @param {Event} e - The form submission event.
             */
            function handleSaveTask(e) {
                e.preventDefault();
                const id = taskIdInput.value || generateId();
                const title = taskTitleInput.value.trim();
                const description = taskDescriptionInput.value.trim();
                const priority = taskPriorityInput.value;
                const category = taskCategoryInput.value.trim();
                // Get date directly from Flatpickr instance to ensure correct format
                const selectedDates = flatpickrInstance.selectedDates;
                const dueDate = selectedDates.length > 0 ? formatDateTime(selectedDates[0]) : null;
                const recurrence = taskRecurrenceInput.value;

                if (!title) {
                    addNotification("Task title cannot be empty.", "warning");
                    taskTitleInput.focus();
                    return;
                }

                if (category) categories.add(category); // Add new category if entered

                 // Find existing task data if editing
                const existingTask = currentEditTaskId ? tasks.find(t => t.id === id) : null;

                const taskData = {
                    id, title, description, priority, category, dueDate, recurrence,
                    completed: existingTask ? existingTask.completed : false,
                    createdAt: existingTask ? existingTask.createdAt : Date.now(),
                    completedAt: existingTask ? existingTask.completedAt : null, // Preserve completion time
                    elapsedTime: existingTask ? existingTask.elapsedTime || 0 : 0,
                    // subtasks: [] // Add subtask saving logic here
                };

                if (currentEditTaskId) {
                    // Update existing task
                    tasks = tasks.map(task => task.id === id ? taskData : task);
                    addNotification(`Task "${taskData.title}" updated.`, "success");
                } else {
                    // Add new task
                    tasks.push(taskData);
                     addNotification(`Task "${taskData.title}" added.`, "success");
                }

                saveState();
                renderAll();
                closeModal(taskModal);
            }

            /**
             * Deletes a task after confirmation.
             * @param {string} taskId - The ID of the task to delete.
             */
            function deleteTask(taskId) {
                const taskIndex = tasks.findIndex(t => t.id === taskId);
                if (taskIndex > -1) {
                    const deletedTask = tasks.splice(taskIndex, 1)[0];
                    stopTimer(taskId); // Stop timer if running
                    delete taskTimers[taskId]; // Remove timer data
                    selectedTaskIds.delete(taskId); // Remove from selection
                    addNotification(`Task "${deletedTask.title}" deleted.`, "info");
                    saveState();
                    renderAll(); // Re-render list, stats, etc.
                }
            }

            /**
             * Shows a confirmation modal before deleting a task.
             * @param {string} taskId - The ID of the task to potentially delete.
             */
            function deleteTaskWithConfirmation(taskId) {
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;

                confirmationTitle.textContent = 'Delete Task';
                confirmationMessage.textContent = `Are you sure you want to delete the task "${escapeHTML(task.title)}"? This action cannot be undone.`;
                confirmActionBtn.className = 'btn btn-danger'; // Red confirm button
                confirmActionBtn.onclick = () => {
                    deleteTask(taskId);
                    closeModal(confirmationModal);
                };
                confirmationModal.classList.add('show');
            }


            /**
             * Toggles the completion status of a task.
             * @param {string} taskId - The ID of the task to toggle.
             */
            function toggleTaskComplete(taskId) {
                tasks = tasks.map(task => {
                    if (task.id === taskId) {
                        const wasCompleted = task.completed;
                        const newCompletedStatus = !wasCompleted;
                        if(newCompletedStatus) {
                            stopTimer(taskId); // Stop timer when marking complete
                        }
                        return {
                            ...task,
                            completed: newCompletedStatus,
                            completedAt: newCompletedStatus ? Date.now() : null
                        };
                    }
                    return task;
                });
                saveState();
                renderAll(); // Re-render to update style and stats
            }

            // --- Multi-Select and Batch Actions ---

            /**
             * Handles selecting or deselecting a task.
             * @param {string} taskId - The ID of the task.
             * @param {boolean} isSelected - Whether the task is being selected.
             */
            function handleTaskSelect(taskId, isSelected) {
                const taskElement = taskList.querySelector(`.task-item[data-task-id="${taskId}"]`);
                if (!taskElement) return;

                if (isSelected) {
                    selectedTaskIds.add(taskId);
                    taskElement.classList.add('selected');
                } else {
                    selectedTaskIds.delete(taskId);
                    taskElement.classList.remove('selected');
                }
                updateBatchActionBar();
            }

            /**
             * Updates the visibility and content of the batch action bar.
             */
            function updateBatchActionBar() {
                const count = selectedTaskIds.size;
                if (count > 0) {
                    selectedCount.textContent = `${count} task${count > 1 ? 's' : ''} selected`;
                    batchActionsBar.style.display = 'flex'; // Show bar
                    // Enable/disable buttons based on selection status if needed
                    // e.g., disable complete if all selected are already complete
                    const allSelectedCompleted = [...selectedTaskIds].every(id => tasks.find(t => t.id === id)?.completed);
                    batchCompleteBtn.disabled = allSelectedCompleted;

                } else {
                    batchActionsBar.style.display = 'none'; // Hide bar
                }
            }

            /**
             * Deletes all selected tasks after confirmation.
             */
            function deleteSelectedTasks() {
                const count = selectedTaskIds.size;
                if (count === 0) return;

                confirmationTitle.textContent = 'Delete Selected Tasks';
                confirmationMessage.textContent = `Are you sure you want to delete ${count} selected task${count > 1 ? 's' : ''}? This action cannot be undone.`;
                confirmActionBtn.className = 'btn btn-danger';
                confirmActionBtn.onclick = () => {
                    let deletedCount = 0;
                    selectedTaskIds.forEach(id => {
                        const taskIndex = tasks.findIndex(t => t.id === id);
                         if (taskIndex > -1) {
                            stopTimer(id);
                            delete taskTimers[id];
                            tasks.splice(taskIndex, 1);
                            deletedCount++;
                         }
                    });
                    selectedTaskIds.clear();
                    addNotification(`${deletedCount} task${deletedCount > 1 ? 's' : ''} deleted.`, "info");
                    saveState();
                    renderAll(); // Will hide batch bar and update list/stats
                    closeModal(confirmationModal);
                };
                confirmationModal.classList.add('show');
            }

            /**
             * Marks all selected tasks as complete.
             */
            function completeSelectedTasks() {
                 const count = selectedTaskIds.size;
                 if (count === 0) return;
                 let completedCount = 0;
                 tasks = tasks.map(task => {
                     if (selectedTaskIds.has(task.id) && !task.completed) {
                         stopTimer(task.id); // Stop timer when marking complete
                         completedCount++;
                         return { ...task, completed: true, completedAt: Date.now() };
                     }
                     return task;
                 });
                 selectedTaskIds.clear(); // Deselect after action
                 if (completedCount > 0) {
                    addNotification(`${completedCount} task${completedCount > 1 ? 's' : ''} marked as complete.`, "success");
                 } else {
                     addNotification("No pending tasks were selected to mark as complete.", "info");
                 }
                 saveState();
                 renderAll(); // Will hide batch bar and update list/stats
            }


            // --- Time Tracking ---

             /**
             * Toggles the timer for a specific task.
             * @param {string} taskId - The ID of the task.
             */
            function toggleTimer(taskId) {
                if (taskTimers[taskId] && taskTimers[taskId].intervalId) {
                    pauseTimer(taskId);
                } else {
                    startTimer(taskId);
                }
            }

           /**
             * Starts the timer for a task.
             * @param {string} taskId - The ID of the task.
             * @param {boolean} isResuming - Internal flag to indicate if resuming after load/render.
             * @param {number|null} explicitStartTime - Used when resuming to sync with persisted start time.
             */
            function startTimer(taskId, isResuming = false, explicitStartTime = null) {
                const task = tasks.find(t => t.id === taskId);
                if (!task || task.completed) return; // Don't start timer for completed tasks

                // If already running with an intervalId, do nothing
                if (taskTimers[taskId]?.intervalId) return;

                // Determine the correct start time
                // If resuming and an explicitStartTime is provided (from localStorage), use that.
                // Otherwise, use the current time.
                const startTime = isResuming && explicitStartTime ? explicitStartTime : Date.now();

                // Ensure elapsedTime property exists on the task object
                if (task.elapsedTime === undefined || task.elapsedTime === null) {
                     task.elapsedTime = 0;
                }

                // Store the base elapsed time *before* this interval starts
                const baseElapsedTime = task.elapsedTime;

                // Clear any potentially orphaned interval ID before setting a new one
                if (taskTimers[taskId]?.intervalId) {
                    clearInterval(taskTimers[taskId].intervalId);
                }

                taskTimers[taskId] = {
                    startTime: startTime, // Record when this *specific* interval started
                    intervalId: setInterval(() => {
                        const now = Date.now();
                        // Calculate time elapsed *since this interval started*
                        const elapsedInInterval = Math.floor((now - startTime) / 1000);
                        // Total elapsed time is the base time + time in this interval
                        const totalElapsedForTask = baseElapsedTime + elapsedInInterval;

                        updateTimerDisplay(taskId, totalElapsedForTask);

                        // Note: We don't update task.elapsedTime here continuously
                        // It's updated only when pausing or saving state.
                    }, 1000) // Update display every second
                };

                updateTimerButton(taskId, true); // Update button style
                if (!isResuming) {
                    // Only save state immediately if it's a manual start, not a resume on load
                    saveState();
                }
            }


            /**
             * Pauses the timer for a task.
             * @param {string} taskId - The ID of the task.
             */
            function pauseTimer(taskId) {
                const timerData = taskTimers[taskId];
                if (!timerData || !timerData.intervalId) return; // Not running

                clearInterval(timerData.intervalId);
                timerData.intervalId = null; // Mark as paused

                const task = tasks.find(t => t.id === taskId);
                if (task && timerData.startTime) {
                    const now = Date.now();
                    // Calculate time elapsed *during the interval that just ended*
                    const elapsedInInterval = Math.floor((now - timerData.startTime) / 1000);
                    // Add this interval's time to the task's total elapsed time
                    task.elapsedTime = (task.elapsedTime || 0) + elapsedInInterval;
                    // Update display one last time with the final accurate time
                    updateTimerDisplay(taskId, task.elapsedTime);
                }

                // Clear the startTime as the interval is no longer active
                timerData.startTime = null;

                updateTimerButton(taskId, false); // Update button style
                saveState(); // Save the accumulated time and paused state
            }


             /**
             * Stops the timer and clears interval (used on delete/complete).
             * @param {string} taskId - The ID of the task.
             */
             function stopTimer(taskId) {
                 const timerData = taskTimers[taskId];
                 if (timerData && timerData.intervalId) {
                     clearInterval(timerData.intervalId);
                     // Update elapsed time one last time before stopping
                     const task = tasks.find(t => t.id === taskId);
                     if (task && timerData.startTime) {
                         const now = Date.now();
                         const elapsedInInterval = Math.floor((now - timerData.startTime) / 1000);
                         task.elapsedTime = (task.elapsedTime || 0) + elapsedInInterval;
                         updateTimerDisplay(taskId, task.elapsedTime); // Update display
                     }
                 }
                 // Remove timer data completely for this task
                 delete taskTimers[taskId];
                 // Ensure button visually resets (renderAll will likely handle this too)
                 updateTimerButton(taskId, false);
                 // saveState() will be called by the calling function (delete/complete)
             }

            /**
             * Stops all running timers (e.g., before page unload or logout).
             */
            function stopAllTimers() {
                console.log("Stopping all timers...");
                Object.keys(taskTimers).forEach(taskId => {
                     if (taskTimers[taskId]?.intervalId) {
                         console.log(`Pausing timer for task ${taskId}`);
                         pauseTimer(taskId); // Pause saves the state correctly
                     }
                 });
                 if (totalTimerInterval) {
                    clearInterval(totalTimerInterval);
                    totalTimerInterval = null;
                 }
                 // Save state one last time after pausing all
                 saveState();
            }

            /**
             * Updates the timer display for a specific task.
             * @param {string} taskId - The ID of the task.
             * @param {number} totalSeconds - The total elapsed seconds for the task.
             */
            function updateTimerDisplay(taskId, totalSeconds) {
                const timerElement = document.getElementById(`timer-${taskId}`);
                if (timerElement) {
                    timerElement.textContent = formatTime(totalSeconds);
                }
            }

             /**
             * Updates the play/pause button style for a task timer.
             * @param {string} taskId - The ID of the task.
             * @param {boolean} isActive - Whether the timer is currently active (has an intervalId).
             */
            function updateTimerButton(taskId, isActive) {
                const taskElement = taskList.querySelector(`.task-item[data-task-id="${taskId}"]`);
                if (!taskElement) return;
                const button = taskElement.querySelector('.timer-toggle-btn');
                const icon = button.querySelector('i');
                const timerStatus = taskElement.querySelector('.timer-status');

                if (isActive) {
                    button.classList.remove('btn-success');
                    button.classList.add('btn-warning');
                    icon.classList.remove('fa-play');
                    icon.classList.add('fa-pause');
                    button.setAttribute('aria-label', 'Pause timer');
                    timerStatus?.classList.add('active');
                } else {
                    button.classList.remove('btn-warning');
                    button.classList.add('btn-success');
                    icon.classList.remove('fa-pause');
                    icon.classList.add('fa-play');
                     button.setAttribute('aria-label', 'Start timer');
                     timerStatus?.classList.remove('active');
                }
            }

            /**
             * Starts the interval to update the total daily timer display.
             */
            function startTotalTimer() {
                if (totalTimerInterval) clearInterval(totalTimerInterval); // Clear existing if any

                const updateTotalDisplay = () => {
                    // Check for daily reset
                    const now = new Date();
                    const todayMidnight = new Date(now).setHours(0, 0, 0, 0);
                    if (todayMidnight > lastMidnightCheck) {
                        console.log("Performing daily timer reset during update.");
                        totalElapsedToday = 0;
                        lastMidnightCheck = todayMidnight;
                        // Reset individual task timers' base values if needed
                        // tasks.forEach(task => { task.elapsedTime = 0; });
                        saveState(); // Save the reset state
                    }

                    // Calculate total based on saved base times + currently running intervals
                    let currentTotalSeconds = 0;
                    tasks.forEach(t => {
                        currentTotalSeconds += (t.elapsedTime || 0); // Add base time
                        const runningTimer = taskTimers[t.id];
                        // If timer is actively running in this session, add the time since it started
                        if (runningTimer && runningTimer.startTime && runningTimer.intervalId) {
                            currentTotalSeconds += Math.floor((Date.now() - runningTimer.startTime) / 1000);
                        }
                    });

                    // Update the display
                    totalTimerValue.textContent = formatTime(currentTotalSeconds);

                    // Update the persisted totalElapsedToday (less frequently perhaps?)
                    // For simplicity, we update it here, but could be done on pause/save only.
                    totalElapsedToday = currentTotalSeconds;

                };

                updateTotalDisplay(); // Initial update
                totalTimerInterval = setInterval(updateTotalDisplay, 1000); // Update every second
            }


            // --- Notifications ---

            /**
             * Adds a toast notification to the screen.
             * @param {string} message - The message to display.
             * @param {string} type - 'info', 'success', 'warning', 'error'.
             * @param {number} duration - Duration in milliseconds (default 5000).
             */
            function addNotification(message, type = 'info', duration = 5000) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                let iconClass = 'fa-info-circle';
                if (type === 'success') iconClass = 'fa-check-circle';
                if (type === 'warning') iconClass = 'fa-exclamation-triangle';
                if (type === 'error') iconClass = 'fa-exclamation-circle';

                toast.innerHTML = `<i class="fas ${iconClass}"></i><span>${escapeHTML(message)}</span>`;
                toastContainer.appendChild(toast);

                // Trigger animations (slide in, then fade out)
                // The CSS handles the animation based on the class addition/removal

                setTimeout(() => {
                    // Start fade out animation via CSS
                    toast.style.animation = 'fadeOutToast 0.4s ease-in forwards';
                    // Remove element after fade out animation completes
                    setTimeout(() => {
                        if (toast.parentNode) { // Check if still attached
                             toast.remove();
                        }
                    }, 400); // Match fade out duration
                }, duration - 400); // Start fade out slightly before duration ends
            }

            /**
             * Checks for tasks due soon or overdue and adds notifications.
             */
            function checkDueDates() {
                 if (!localStorage.getItem('loggedInUser')) return; // Don't check if not logged in

                const now = new Date();
                const today = new Date(now).setHours(0, 0, 0, 0);
                const tomorrow = new Date(today); tomorrow.setDate(new Date(today).getDate() + 1);

                let upcomingNotifications = [];
                let overdueNotifications = [];

                tasks.forEach(task => {
                    if (!task.completed && task.dueDate) {
                         try {
                            const dueDate = new Date(task.dueDate);
                            const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate());

                            if (dueDateOnly < today) {
                                overdueNotifications.push({
                                    id: task.id,
                                    title: task.title,
                                    type: 'error',
                                    message: `Task "${escapeHTML(task.title)}" is overdue!`
                                });
                            } else if (dueDateOnly.getTime() === today.getTime()) {
                                upcomingNotifications.push({
                                    id: task.id,
                                    title: task.title,
                                    type: 'warning',
                                    message: `Task "${escapeHTML(task.title)}" is due today.`
                                });
                            } else if (dueDateOnly.getTime() === tomorrow.getTime()) {
                                upcomingNotifications.push({
                                    id: task.id,
                                    title: task.title,
                                    type: 'info',
                                    message: `Task "${escapeHTML(task.title)}" is due tomorrow.`
                               });
                            }
                        } catch(e) { /* Ignore tasks with invalid dates */ }
                    }
                });

                updateNotificationUI([...overdueNotifications, ...upcomingNotifications]);
            }

            /**
             * Updates the notification bell and dropdown list.
             * @param {Array} notifications - Array of notification objects.
             */
            function updateNotificationUI(notifications) {
                 // Simple approach: Replace list content each time
                 notificationList.innerHTML = ''; // Clear previous
                 let count = 0;

                 if (notifications.length === 0) {
                     notificationList.innerHTML = '<div class="notification-empty">No new notifications</div>';
                     notificationCount.classList.add('hidden');
                     notificationCount.textContent = '0';
                     return;
                 }

                 notifications.forEach(notif => {
                     // Basic check to avoid spamming the *same* notification type for a task repeatedly
                     // This needs more sophisticated logic for persistent notifications
                     // if (localStorage.getItem(`notif_${notif.id}_${notif.type}_sent`)) return;

                     const item = document.createElement('div');
                     item.className = `notification-item ${notif.type}`;
                     item.dataset.taskId = notif.id;
                     let iconClass = 'fa-info-circle';
                     if (notif.type === 'success') iconClass = 'fa-check-circle';
                     if (notif.type === 'warning') iconClass = 'fa-exclamation-triangle';
                     if (notif.type === 'error') iconClass = 'fa-exclamation-circle';

                     item.innerHTML = `<i class="fas ${iconClass}"></i> <span>${notif.message}</span>`;
                     item.addEventListener('click', () => {
                         // Scroll to task or open modal?
                         const taskElement = taskList.querySelector(`.task-item[data-task-id="${notif.id}"]`);
                         if (taskElement) {
                             taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                             // Highlight briefly?
                             taskElement.style.transition = 'background-color 0.1s ease-in-out, transform 0.1s ease-in-out';
                             taskElement.style.backgroundColor = 'var(--lm-warning)'; // Use appropriate var
                              taskElement.style.transform = 'scale(1.02)';
                             setTimeout(() => {
                                taskElement.style.backgroundColor = '';
                                taskElement.style.transform = '';
                             }, 1000);
                         } else {
                             openTaskModal(notif.id); // If task not visible (filtered out)
                         }
                         notificationList.style.display = 'none'; // Close list after click
                     });
                     notificationList.appendChild(item);
                     count++;
                     // Mark as sent (simple flag)
                     // localStorage.setItem(`notif_${notif.id}_${notif.type}_sent`, 'true');
                 });

                 if (count > 0) {
                     notificationCount.textContent = count;
                     notificationCount.classList.remove('hidden');
                 } else {
                     notificationList.innerHTML = '<div class="notification-empty">No new notifications</div>';
                     notificationCount.classList.add('hidden');
                     notificationCount.textContent = '0';
                 }
            }


            // --- Theme Toggling ---

            /**
             * Toggles between light and dark mode.
             */
            function toggleTheme() {
                const isDarkMode = document.body.classList.toggle('dark-mode');
                updateTheme(isDarkMode ? 'dark' : 'light');
                saveState(); // Save the new theme preference
            }

            /**
             * Updates UI elements based on the current theme.
             * @param {string} theme - 'light' or 'dark'.
             */
            function updateTheme(theme) {
                const isDarkMode = theme === 'dark';
                document.body.classList.toggle('dark-mode', isDarkMode);
                themeToggleBtn.innerHTML = `<i class="fas ${isDarkMode ? 'fa-sun' : 'fa-moon'}"></i>`; // Update icon
                themeToggleBtn.setAttribute('aria-label', `Switch to ${isDarkMode ? 'light' : 'dark'} mode`);

                 // Update Flatpickr theme
                if (flatpickrInstance && flatpickrInstance.calendarContainer) {
                     flatpickrInstance.calendarContainer.classList.toggle('dark-mode', isDarkMode);
                }
                // Also update any other date pickers if added later
            }

            // --- View Switching ---
            function switchView(view) {
                 if (view === currentView) return;

                 currentView = view;

                 const isListView = view === 'list';
                 listViewBtn.classList.toggle('active', isListView);
                 listViewBtn.setAttribute('aria-pressed', isListView);
                 graphViewBtn.classList.toggle('active', !isListView);
                 graphViewBtn.setAttribute('aria-pressed', !isListView);

                 // Add transition classes for smoother visual change
                 taskListContainer.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                 graphViewContainer.style.transition = 'opacity 0.3s ease, transform 0.3s ease';


                 if (isListView) {
                     graphViewContainer.classList.add('view-hidden');
                     taskListContainer.classList.remove('view-hidden');
                 } else {
                     taskListContainer.classList.add('view-hidden');
                     graphViewContainer.classList.remove('view-hidden');
                 }
            }


            // --- Utility Functions ---

            /**
             * Generates a simple unique ID.
             * @returns {string}
             */
            function generateId() {
                return '_' + Math.random().toString(36).substr(2, 9);
            }

            /**
             * Escapes HTML special characters to prevent XSS.
             * @param {string} str - The string to escape.
             * @returns {string} - The escaped string.
             */
            function escapeHTML(str) {
                 if (str === null || str === undefined) return '';
                 return String(str).replace(/[&<>"']/g, function (match) {
                    return {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    }[match];
                });
            }

            /**
             * Formats seconds into HH:MM:SS string.
             * @param {number} totalSeconds - Total seconds.
             * @returns {string} - Formatted time string.
             */
            function formatTime(totalSeconds) {
                if (isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = Math.floor(totalSeconds % 60);
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

             /**
             * Formats a Date object into 'YYYY-MM-DD HH:MM' string for storage/Flatpickr.
             * @param {Date} date - The date object.
             * @returns {string|null} - Formatted date-time string or null.
             */
            function formatDateTime(date) {
                if (!date || !(date instanceof Date) || isNaN(date)) return null;
                 try {
                     const year = date.getFullYear();
                     const month = String(date.getMonth() + 1).padStart(2, '0');
                     const day = String(date.getDate()).padStart(2, '0');
                     const hours = String(date.getHours()).padStart(2, '0');
                     const minutes = String(date.getMinutes()).padStart(2, '0');
                     return `${year}-${month}-${day} ${hours}:${minutes}`;
                 } catch (e) {
                     console.error("Error formatting date:", date, e);
                     return null;
                 }
            }

            /**
             * Formats a Date object into a user-friendly string (e.g., "Today, 10:30 AM", "Tomorrow", "Apr 20, 2025").
             * @param {Date} date - The date object.
             * @returns {string} - Friendly date string.
             */
            function formatFriendlyDate(date) {
                if (!date || !(date instanceof Date) || isNaN(date)) return 'No due date';

                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const tomorrow = new Date(today); tomorrow.setDate(today.getDate() + 1);
                const inputDateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true };
                const dateOptions = { month: 'short', day: 'numeric', year: date.getFullYear() !== today.getFullYear() ? 'numeric' : undefined };

                let dateString;
                if (inputDateOnly.getTime() === today.getTime()) {
                    dateString = 'Today';
                } else if (inputDateOnly.getTime() === tomorrow.getTime()) {
                    dateString = 'Tomorrow';
                } else {
                    dateString = date.toLocaleDateString(undefined, dateOptions);
                }

                // Check if time is set (not midnight 00:00)
                if (date.getHours() !== 0 || date.getMinutes() !== 0) {
                    return `${dateString}, ${date.toLocaleTimeString(undefined, timeOptions)}`;
                } else {
                    return dateString; // Just the date if time is midnight
                }
            }


            /**
             * Initializes Flatpickr instances.
             */
             let flatpickrInstance;
             function initializeDatePickers() {
                 flatpickrInstance = flatpickr("#taskDueDate", {
                    enableTime: true,
                    dateFormat: "Y-m-d H:i", // Matches formatDateTime
                    altInput: true, // Human-readable format
                    altFormat: "M j, Y h:i K", // Display format
                    time_24hr: false,
                     onReady: function(selectedDates, dateStr, instance) {
                        // Apply dark mode on init if necessary
                        if (document.body.classList.contains('dark-mode')) {
                             instance.calendarContainer.classList.add('dark-mode');
                        }
                     },
                     // Ensure theme updates when mode changes
                     // Note: updateTheme function now handles this
                 });
             }

            // --- Login/Registration Specific Functions ---

            /**
             * Handles the login form submission.
             * @param {Event} e - Form submission event.
             */
            function handleLogin(e) {
                e.preventDefault();
                const username = loginUsernameInput.value.trim();
                const password = loginPasswordInput.value; // In real app, send to server for verification

                if (!username || !password) {
                    addNotification("Please enter both username and password.", "warning");
                    return;
                }

                // --- Simulation ---
                // Check if user exists in our simulated storage
                const registeredUsers = JSON.parse(localStorage.getItem('registeredUsers') || '{}');
                if (registeredUsers[username]) {
                    // In a real app, you'd verify the password hash here.
                    // For simulation, just knowing the username exists is enough.
                    localStorage.setItem('loggedInUser', username);
                    checkLoginStatus(); // Transition to app view
                } else {
                    addNotification("Invalid username or password.", "error");
                }
                // --- End Simulation ---

                loginForm.reset(); // Clear form fields
            }

            /**
             * Opens the registration modal.
             */
            function openRegistrationModal() {
                registrationForm.reset();
                registrationModal.classList.add('show');
                regUsernameInput.focus();
            }

             /**
             * Handles the registration form submission.
             * @param {Event} e - Form submission event.
             */
            function handleRegistration(e) {
                e.preventDefault();
                const username = regUsernameInput.value.trim();
                const password = regPasswordInput.value;
                const confirmPassword = regConfirmPasswordInput.value;

                if (!username || !password || !confirmPassword) {
                    addNotification("Please fill in all registration fields.", "warning");
                    return;
                }

                if (password !== confirmPassword) {
                    addNotification("Passwords do not match.", "warning");
                    regConfirmPasswordInput.focus();
                    return;
                }

                // --- Simulation ---
                const registeredUsers = JSON.parse(localStorage.getItem('registeredUsers') || '{}');

                if (registeredUsers[username]) {
                    addNotification("Username already taken. Please choose another.", "warning");
                    regUsernameInput.focus();
                    return;
                }

                // Store the new user (insecurely for simulation)
                registeredUsers[username] = { registeredAt: Date.now() }; // Store minimal info
                localStorage.setItem('registeredUsers', JSON.stringify(registeredUsers));
                // --- End Simulation ---

                addNotification(`User "${username}" registered successfully! Please log in.`, "success");
                closeModal(registrationModal);
                loginUsernameInput.value = username; // Pre-fill login form
                loginPasswordInput.focus();
            }


            // --- Event Listeners ---

            // Login/Logout/Register
            loginForm.addEventListener('submit', handleLogin);
            registerLink.addEventListener('click', openRegistrationModal); // Changed from href="#"
            registrationForm.addEventListener('submit', handleRegistration);

            logoutBtn.addEventListener('click', () => {
                 stopAllTimers(); // Stop timers before logging out
                 localStorage.removeItem('loggedInUser');
                 // Clear user-specific data? Optional.
                 // Example: localStorage.removeItem(`user_${username}_tasks`);

                 // Reset state variables that hold user data
                 tasks = [];
                 categories = new Set();
                 selectedTaskIds = new Set();
                 taskTimers = {};
                 totalElapsedToday = 0;
                 if(totalTimerInterval) clearInterval(totalTimerInterval);
                 totalTimerInterval = null;

                 checkLoginStatus(); // Transition back to login view
                 loginForm.reset();
            });


            // Theme Toggle
            themeToggleBtn.addEventListener('click', toggleTheme);

            // Modals
            addTaskBtn.addEventListener('click', () => openTaskModal());
            taskForm.addEventListener('submit', handleSaveTask);
            // Close modal buttons (now handles all modals)
            document.querySelectorAll('[data-dismiss="modal"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const modal = btn.closest('.modal');
                    if (modal) closeModal(modal);
                });
            });
            // Close modal on overlay click (now handles all modals)
            window.addEventListener('click', (e) => {
                 if (e.target.classList.contains('modal') && e.target.classList.contains('show')) {
                     closeModal(e.target);
                 }
                 // Close notification list if clicking outside
                 if (notificationList.style.display === 'block' && !notificationBtn.contains(e.target) && !notificationList.contains(e.target)) {
                    notificationList.style.display = 'none';
                 }
            });
             // Close modal on Escape key (now handles all modals)
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.modal.show').forEach(modal => closeModal(modal));
                    if (notificationList.style.display === 'block') notificationList.style.display = 'none';
                    if (selectedTaskIds.size > 0) { // Deselect on escape?
                        // selectedTaskIds.clear(); renderAll(); // Optional: deselect
                    }
                }
                // Keyboard Shortcuts (Example)
                 if (localStorage.getItem('loggedInUser')) { // Only allow shortcuts if logged in
                     if (e.altKey && e.key === 'n') { // Alt + N for New Task
                         e.preventDefault();
                         openTaskModal();
                     }
                     if (e.altKey && e.key === 't') { // Alt + T for Theme Toggle
                         e.preventDefault();
                         toggleTheme();
                     }
                 }
            });


            // Filters and Sorting
            filterPriority.addEventListener('change', renderTasks);
            filterCategory.addEventListener('change', renderTasks);
            filterDueDate.addEventListener('change', renderTasks);
            filterStatus.addEventListener('change', renderTasks);
            sortTasks.addEventListener('change', renderTasks);
            resetFiltersBtn.addEventListener('click', () => {
                filterPriority.value = 'all';
                filterCategory.value = 'all';
                filterDueDate.value = 'all';
                filterStatus.value = 'all';
                sortTasks.value = 'default';
                renderTasks();
            });

            // Batch Actions
            batchCompleteBtn.addEventListener('click', completeSelectedTasks);
            batchDeleteBtn.addEventListener('click', deleteSelectedTasks);

            // View Switching
            listViewBtn.addEventListener('click', () => switchView('list'));
            graphViewBtn.addEventListener('click', () => switchView('graph'));

            // Import/Export
            exportBtn.addEventListener('click', () => {
                if (!localStorage.getItem('loggedInUser')) return; // Prevent if not logged in
                try {
                    // Export only tasks and categories for the current user
                    const dataToExport = {
                        tasks: tasks,
                        categories: Array.from(categories)
                    };
                    const dataStr = JSON.stringify(dataToExport, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    const timestamp = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
                    const username = localStorage.getItem('loggedInUser') || 'user';
                    link.download = `tasks_${username}_${timestamp}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    addNotification('Tasks exported successfully.', 'success');
                } catch (error) {
                    console.error("Export Error:", error);
                    addNotification(`Export failed: ${error.message}`, 'error');
                }
            });

            importBtn.addEventListener('click', () => {
                 if (!localStorage.getItem('loggedInUser')) return; // Prevent if not logged in
                 importFile.click()
            });
            importFile.addEventListener('change', (event) => {
                if (!localStorage.getItem('loggedInUser')) return; // Prevent if not logged in
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        // Validate imported structure
                        if (importedData && Array.isArray(importedData.tasks)) {
                            // Option 1: Replace existing tasks for the current user
                            // tasks = importedData.tasks.map(t => ({ ...t, id: t.id || generateId() })); // Ensure IDs exist
                            // categories = new Set(importedData.categories || []);

                            // Option 2: Merge with existing tasks (simple merge, gives new IDs to avoid conflicts)
                            const newTasks = importedData.tasks.map(t => ({ ...t, id: generateId() })); // Give new IDs
                            tasks = [...tasks, ...newTasks];
                            const importedCategories = new Set(importedData.categories || []);
                            importedCategories.forEach(cat => categories.add(cat));


                            saveState(); // Save merged data for the current user
                            renderAll();
                            addNotification(`Successfully imported ${importedData.tasks.length} tasks.`, 'success');
                        } else {
                            throw new Error('Invalid file format. Expected { tasks: [], categories?: [] }');
                        }
                    } catch (error) {
                        console.error("Import Error:", error);
                        addNotification(`Import failed: ${error.message}`, 'error');
                    } finally {
                         importFile.value = ''; // Reset file input
                    }
                };
                reader.onerror = () => {
                     addNotification('Error reading file.', 'error');
                     importFile.value = ''; // Reset file input
                }
                reader.readAsText(file);
            });

            // General UI Handlers
            notificationBtn.addEventListener('click', (e) => {
                if (!localStorage.getItem('loggedInUser')) return; // Prevent if not logged in
                e.stopPropagation();
                notificationList.style.display = notificationList.style.display === 'block' ? 'none' : 'block';
                // Maybe clear count when opened? Or when notifications are clicked?
                // notificationCount.classList.add('hidden');
            });
            refreshLogo.addEventListener('click', (e) => {
                 e.preventDefault(); // Prevent navigation if it's an anchor
                 if (!localStorage.getItem('loggedInUser')) return; // Prevent if not logged in
                 renderAll();
                 addNotification('View refreshed.', 'info', 2000);
            });

            // Stop timers before unloading page
            window.addEventListener('beforeunload', () => {
                // Only stop timers if a user is actually logged in
                if (localStorage.getItem('loggedInUser')) {
                    stopAllTimers();
                }
            });

        }); // End DOMContentLoaded
    </script>
</body>
</html>
